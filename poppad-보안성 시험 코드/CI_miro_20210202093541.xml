<?xml version="1.0" encoding="UTF-8"?>
<ci.CodeInspectorResult>
	<summary>
		<prjName></prjName>
		<toolName>CodeScroll Code Inspector</toolName>
		<toolVersion>3.7.4.201612281427</toolVersion>
		<numberOfCodeViolation>219</numberOfCodeViolation>
	</summary>
	<source>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<crc32>9743c5d2</crc32>
	</source>
	<source>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<crc32>4b9511cd</crc32>
	</source>
	<source>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<crc32>8fca5527</crc32>
	</source>
	<source>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<crc32>d46300a5</crc32>
	</source>
	<source>
		<fileName>C:\Temp\QA_source\miro\Q_S.h</fileName>
		<crc32>ca4f4382</crc32>
	</source>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_01</rule>
		<ruleTitle><![CDATA[The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation’s translation limits]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>
The program shall use only those features of the C language and its library that are specified in the<br/>
chosen version of The Standard (see Section 3.1).<br/><br/>
The Standard permits implementations to provide language extensions and the use of such extensions<br/>
is permitted by this rule.<br/><br/>
Except when making use of a language extension, a program shall not:<br/><br/>
• Contain any violations of the language syntax described in The Standard;<br/><br/>
• Contain any violations of the constraints imposed by The Standard.<br/><br/>
A program shall not exceed the translation limits imposed by the implementation. The minimum<br/>
translation limits are specified by The Standard but an implementation may provide higher limits.<br/><br/>
Note: a conforming implementation generates a diagnostic for syntax and constraint violations but be<br/>
aware that:<br/><br/>
• The diagnostic need not necessarily be an error but could, for example, be a warning;<br/><br/>
• The program may be translated and an executable generated despite the presence of a<br/>
syntax or constraint violation;<br/><br/>
Note: a conforming implementation does not need to generate a diagnostic when a translation limit is<br/>
exceeded; an executable may be generated but it is not guaranteed to execute correctly.<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>
Problems associated with language features that are outside the supported versions of ISO/IEC 9899<br/>
have not been considered during development of these guidelines.<br/><br/>
There is anecdotal evidence of some non-conforming implementations failing to diagnose constraint<br/>
violations, for example in [38] p135, example 2 entitled “Error of writing into the const area”.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Dir 2.1, Rule 1.2<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_02</rule>
		<ruleTitle><![CDATA[Language extensions should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

A program that relies on language extensions may be less portable than one that does not. Although<br/>
The Standard requires that a conforming implementation document any extensions that it provides<br/>
to the language, there is a risk that this documentation might not provide a full description of the<br/>
behaviour in all circumstances.<br/><br/>

If this rule is not applied, the decision to use each language extension should be justified in the<br/>
project’s design documentation. The methods by which valid use of each extension will be assured,<br/>
for example checking the compiler and its diagnostics, should also be documented.<br/><br/>

It is recognized that it is necessary to use language extensions in embedded systems. The Standard<br/>
requires that an extension does not alter the behaviour of any strictly conforming program. For<br/>
example, a compiler might implement, as an extension, full evaluation of binary logical operators<br/>
even though The Standard specifi es that evaluation stops as soon as the result can be determined.<br/>
Such an extension does not conform to The Standard because side effects in the right-hand operand<br/>
of a logical AND operator would always occur, giving rise to a different behaviour.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 1.1<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_01_03</rule>
		<ruleTitle><![CDATA[There shall be no occurrence of undefined or critical unspecified behaviour]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

Some undefined and unspecified behaviour s are dealt with by specific rules. This rule prevents all<br/>
other undefined and critical unspecified behaviours. Appendix H lists the undefined behaviours and<br/>
those unspecified behaviours that are considered critical.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

Any program that gives rise to undefined or unspecified behaviour may not behave in the expected<br/>
manner. In many cases, the effect is to make the program non-portable but it is also possible for more<br/>
serious problems to occur. For example, undefined behaviour might affect the result of a computation.<br/>
If correct operation of the software is dependent on this computation then system safety might be<br/>
compromised. The problem is particularly difficult to detect if the undefined behaviour only manifests<br/>
itself on rare occasions.<br/><br/>

Many of the MISRA C guidelines have been designed to avoid certain undefined and unspecified<br/>
behaviours. For example, compliance with all of Rule 11.4, Rule 11.8 and Rule 19.2 ensures that it is not<br/>
possible in C to create a non-const qualified pointer to an object declared with a const-qualified type.<br/>
This avoids C90 [Undefined 39] and C99 [Undefined 61]. However, other behaviours are not covered<br/>
by specific guidelines for example because:<br/><br/>

• It is unlikely that the behaviour will be encountered;<br/><br/>

• There is no practical guidance that can be given other than the obvious statement that the<br/>
behaviour should be avoided.<br/><br/>

Instead of introducing a guideline for each undefined and critical unspecified behaviour, the MISRA C<br/>
Guidelines directly address those that are considered most important and most likely to occur in<br/>
practice. Those behaviours that do not have specific guidelines are all covered together by this single<br/>
rule. Appendix H lists all undefined and critical unspecified behaviours, along with the MISRA C<br/>
guidelines that prevent their occurrence. It therefore indicates which behaviours are expected to be<br/>
prevented by this rule and which behaviours are covered by other rules.<br/><br/>

Note: some implementations may provide well-defined behaviour for some of the undefined and<br/>
unspecified behaviours listed in The Standard. If such well-defined behaviours are relied upon,<br/>
including by means of a language extension, it will be necessary to deviate this rule in respect of those<br/>
behaviours.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Dir 4.1<br/>
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_19_01</rule>
		<ruleTitle><![CDATA[An object shall not be assigned or copied to an overlapping object]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The behaviour is undefined when two objects are created which have some overlap in memory and<br />
one is assigned or copied to the other.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
The following are permitted because the behaviour is well-defined:<br />
1. Assignment between two objects that overlap exactly and have compatible types (ignoring<br />
their type qualifiers)<br />
<br />
2. Copying between objects that overlap partially or completely using The Standard Library<br />
function memmove
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 19.2<br/>
]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_19_02</rule>
		<ruleTitle><![CDATA[The union keyword should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
A union member can be written and the same member can then be read back in a well-defined<br />
manner.<br />
<br />
However, if a union member is written and then a different union member is read back, the behaviour<br />
depends on the relative sizes of the members:<br />
<br />
&bull; If the member read is wider than the member written then the value is unspecified;<br />
&bull; Otherwise, the value is implementation-defined.<br />
<br />
The Standard permits the bytes of a union member to be accessed by means of another member<br />
whose type is array of unsigned char. However, since it is possible to access bytes with unspecified<br />
values, unions should not be used.<br />
<br />
If this rule is not followed, the kinds of behaviour that need to be determined are:<br />
<br />
&bull; Padding &mdash; how much padding is inserted at the end of the union;<br />
<br />
&bull; Alignment &mdash; how are members of any structures within the union aligned;<br />
<br />
&bull; Endianness &mdash; is the most significant byte of a word stored at the lowest or highest memory <br />
address;<br />
<br />
&bull; Bit-order &mdash; how are bits numbered within bytes and how are bits allocated to bit fields.
<br /><br />
<span style="color:#B73232">See also</span>&nbsp;Rule 19.1<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_01</rule>
		<ruleTitle><![CDATA[Conversions shall not be performed between a pointer to a function and any other type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br><br>
A pointer to a function shall only be converted into or from a pointer to a function with a compatible<br />
type.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The conversion of a pointer to a function into or from any of:<br />
<br />
&bull; Pointer to object;<br />
<br />
&bull; Pointer to incomplete;<br />
<br />
&bull; void *<br />
<br />
results in undefined behaviour.<br />
<br />
If a function is called by means of a pointer whose type is not compatible with the called function,<br />
the behaviour is undefined. Conversion of a pointer to a function into a pointer to a function with<br />
a different type is permitted by The Standard. Conversion of an integer into a pointer to a function<br />
is also permitted by The Standard. However, both are prohibited by this rule in order to avoid the<br />
undefined behaviour that would result from calling a function using an incompatible pointer type.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
1. A null pointer constant may be converted into a pointer to a function;<br />
<br />
2. A pointer to a function may be converted into void;<br />
<br />
3. A function type may be implicitly converted into a pointer to that function type.<br />
<br />
Note: exception 3 covers the implicit conversions described in C90 Section 6.2.2.1 and C99<br />
Section 6.3.2.1. These conversions commonly occur when:<br />
<br />
&bull; A function is called directly, i.e. using a function identifier to denote the function to be called;<br />
<br />
&bull; A function is assigned to a function pointer.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_03</rule>
		<ruleTitle><![CDATA[A cast shall not be performed between a pointer to object type and a pointer to a different object type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to the unqualified types that are pointed to by the pointers.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Casting a pointer to object into a pointer to a different object may result in a pointer that is not<br />
correctly aligned, resulting in undefined behaviour.<br />
<br />
Even if conversion is known to produce a pointer that is correctly aligned, the behaviour may be<br />
undefined if that pointer is used to access an object. For example, if an object whose type is int is<br />
accessed as a short the behaviour is undefined even if int and short have the same representation and<br />
alignment requirements. See C90 Section 6.3, C99 Section 6.5, paragraph 7 for details.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
It is permitted to convert a pointer to object type into a pointer to one of the object types char, signed<br />
char or unsigned char. The Standard guarantees that pointers to these types can be used to access the<br />
individual bytes of an object.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_02</rule>
		<ruleTitle><![CDATA[Conversions shall not be performed between a pointer to an incomplete type and any other type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br>
<br />
A pointer to an incomplete type shall not be converted into another type.<br />
A conversion shall not be made into a pointer to incomplete type.<br />
Although a pointer to void is also a pointer to an incomplete type, this rule does not apply to pointers<br />
to void as they are covered by Rule 11.5.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Conversion into or from a pointer to an incomplete type may result in a pointer that is not correctly<br />
aligned, resulting in undefi ned behaviour .<br />
Conversion of a pointer to an incomplete type into or from a fl oating type always results in undefi ned<br />
behaviour.<br />
Pointers to an incomplete type are sometimes used to hide the representation of an object. Converting<br />
a pointer to an incomplete type into a pointer to object would break this encapsulation.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
1. A null pointer constant may be converted into a pointer to an incomplete type.<br />
2. A pointer to an incomplete type may be converted into void.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br>
<br />
An integer constant expression with the value 0 shall be derived from expansion of the macro NULL if it<br />
appears in any of the following contexts:<br />
<br />
&bull; As the value being assigned to a pointer;<br />
<br />
&bull; As an operand of an == or != operator whose other operand is a pointer;<br />
<br />
&bull; As the second operand of a ?: operator whose third operand is a pointer;<br />
<br />
&bull; As the third operand of a ?: operator whose second operand is a pointer.<br />
<br />
Ignoring whitespace and any surrounding parentheses, any such integer constant expression shall<br />
represent the entire expansion of NULL.<br />
<br />
Note: a null pointer constant of the form (void *)0 is permitted, whether or not it was expanded from<br />
NULL.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Using NULL rather than 0 makes it clear that a null pointer constant was intended.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_08</rule>
		<ruleTitle><![CDATA[A cast shall not remove any const or volatile qualification from the type pointed to by a pointer]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br>
<br />
Any attempt to re move the qualification associated with the addressed type by using casting is a<br />
violation of the principle of type qualification.<br />
<br />
Note: the qualification referred to here is not the same as any qualification that may be applied to the<br />
pointer itself.<br />
<br />
Some of the problems that might arise if a qualifier is removed from the addressed object are:<br /><br />
&bull; Removing a const qualifi er might circumvent the read-only status of an object and result in it<br />
being modified;<br />
<br />
&bull; Removing a const qualifier might result in an exception when the object is accessed;<br />
<br />
&bull; Removing a volatile qualifier might result in accesses to the object being optimized away.<br />
Note: removal of the C99 restrict type qualifier is benign.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_05</rule>
		<ruleTitle><![CDATA[A conversion should not be performed from pointer to void into pointer to object]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br>
<br />
Conversion of a pointer to void into a pointer to object may result in a pointer that is not correctly<br />
aligned, resulting in undefined behaviour. It should be avoided where possible but may be necessary,<br />
for example when dealing with memory allocation functions. If conversion from a pointer to object<br />
into a pointer to void is used, care should be taken to ensure that any pointers produced do not give<br />
rise to the undefined behaviour discussed under Rule 11.3.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
A null pointer constant that has type pointer to void may be converted into pointer to object.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_04</rule>
		<ruleTitle><![CDATA[A conversion should not be performed between a pointer to object and an integer type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br>
<br />
A pointer should not be converted into an integer.<br />
An integer should not be converted into a pointer.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Conversion of an integer into a pointer to object may result in a poin ter that is not correctly aligned,<br />
resulting in undefined behaviour.<br />
<br />
Conversion of a pointer to object into an integ er may produce a value that cannot be represented in<br />
the chosen integer type resulting in undefined behaviour.<br />
<br />
Note: the C99 types intptr_t and uintptr_t, declared in <stdint.h>, are respectively signed and<br />
unsigned integer types capable of representing pointer values. Despite this, conversions between a<br />
pointer to object and these types is not permitted by this rule because their use does not avoid the<br />
undefined behaviour associated with misaligned pointers.<br />
<br />
Casting between a pointer and an integer type should be avoided where possible, but may be<br />
necessary when addressing memory mapped registers or other hardware specific features. If casting<br />
between integers and pointers is used, care should be taken to ensure that any pointers produced do<br />
not give rise to the undefined behaviour discussed under Rule 11.3.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
A null pointer constant that has integer type may be converted into a pointer to object.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_07</rule>
		<ruleTitle><![CDATA[A cast shall not b e performed between pointer to object and a non-integer arithmetic type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br>
<br />
For the purposes of this rule a non-integer arithmetic type means one of:<br />
<br />
&bull; Essentially Boolean;<br />
<br />
&bull; Essentially character;<br />
<br />
&bull; Essentially enum;<br />
<br />
&bull; Essentially floating.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Conversion of an essentially Boolean, essentially character or essentially enum type into a pointer to<br />
object may result in a pointer that is not correctly aligned, resulting in undefined behaviour.<br />
<br />
Conversion of a pointer to object into an essentially Boolean, essentially character or essentially enum type<br />
may produce a value that cannot be represented in the chosen integer type resulting in undefined<br />
behaviour.<br />
<br />
Conversion of a pointer to object into or from an essentially floating type results in undefined behaviour

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 11.4<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_11_06</rule>
		<ruleTitle><![CDATA[A cast shall not b e performed between pointer to void and an arithmetic type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br>
<br />
Conversion of an integer into a pointer to void may result in a pointer that is not correctly aligned,<br />
resulting in undefined behaviour.<br />
<br />
Conversion of a pointer to void into an integer may produce a value that cannot be represented in the<br />
chosen integer type resulting in undefined behaviour.<br />
<br />
Conversion between any non-integer arithmetic type and pointer to void is undefined.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
An integ er constant expression with value 0 may be cast into pointer to void.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_09</rule>
		<ruleTitle><![CDATA[Identifi ers that defi ne objects or functions with internal linkage should]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/>
<br />
An identifier used as an external identifier shall not be used for any other purpose in any name space<br />
or translation unit, even if it denotes an object with no linkage.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Enforcing uniqueness of identifier names in this manner helps avoid confusion. Identifiers of objects<br />
that have no linkage need not be unique since there is minimal risk of such confusion.<br /><br />

<span style="color:#B73232">See also</span> &nbsp;Rule 8.10<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_03</rule>
		<ruleTitle><![CDATA[An identifier declared in an inner scope shall not hide an identifier declared in an outer scope]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

An identifier declared in an inner scope shall be distinct from any identifier declared in an outer scope.<br/>
The definition of distinct depends on t he implementation and the version of the C language that is<br/>
being used:<br/><br/>

• In C90 the minimum requirement is that the first 31 characters are significant;<br/><br/>

• In C99 the minimum requirement is that the first 63 characters are significant, with each<br/><br/>

universal character or extended source character counting as a single character.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If an identifier is declared in an inner scope but is not distinct from an identifier that already exists in<br/>
an outer scope, then the inner-most declaration will “hide” the outer one. This may lead to developer<br/>
confusion.<br/><br/>

Note: An identifier declared in one name space does not hide an identifier declared in a different name<br/>
space.<br/><br/>

The terms outer and inner scope are defined as follows:<br/><br/>

• Identifiers that have file scope can be considered as having the outermost scope;<br/><br/>

• Identifiers that have block scope have a more inner scope;<br/><br/>

• Successive, nested blocks, introduce more inner scopes.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.2, Rule 5.8<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_04</rule>
		<ruleTitle><![CDATA[Macro identifiers shall be distinct]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br/><br/>
This rule requires that, when a macro is being defined, its name be distinct from:<br />
<br />
&bull; the names of the other macros that are currently defined; and<br />
<br />
&bull; the names of their parameters.<br />
<br />
It also requires that the names of the parameters of a given macro be distinct from each other but<br />
does not require that macro parameters names be distinct across two different macros.<br />
<br />
The definition of distinct depends on the implementation and on the version of the C language that<br />
is being used:<br />
<br />
&bull; In C90 the minimum requirement is that the first 31 characters of macro identifiers are<br />
significant;<br />
<br />
&bull; In C99 the minimum requirement is that the first 63 characters of macro identifiers are<br />
significant.<br />
<br />
In practice, implementations may provide greater limits. This rule requires that macro identifiers be<br />
distinct within the limits imposed by the implementation.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
If two macro identifiers diff er only in non-significant characters, the behaviour is undefined. Since macro<br />
parameters are active only during the expansion of their macro, there is no issue with parameters in<br />
one macro being confused with parameters in another macro.<br />
<br />
If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in The Standard.<br />
<br />
Long macro identifiers may impair the readability of code. While many automatic code generation<br />
systems produce long macro identifiers, there is a good argument for keeping macro identifier lengths<br />
well below this limit.<br />
<br />
Note: In C99, if an extended source character appears in a macro name and that character does not<br />
have a corresponding universal character, The Standard does not specify how many characters it<br />
occupies.<br /><br />

<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.4<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_01</rule>
		<ruleTitle><![CDATA[External identifiers shall be distinct]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

This rule requires that different external identifiers be distinct within the limits imposed by the<br/>
implementation.<br/><br/>

The definition of distinct depends on the implementation and on the version of the C language that<br/>
is being used:<br/><br/>

• In C90 the minimum requirement is that the first 6 characters of external identifiers are<br/>
significant but their case is not required to be significant;<br/><br/>

• In C99 the minimum requirement is that the first 31 characters of external identifiers are<br/>
significant, with each universal character or corresponding extended source character<br/>
occupying between 6 and 10 characters.<br/><br/>

In practice, many implementations provide greater limits. For example it is common for external<br/>
identifiers in C90 to be case-sensitive and for at least the fi rst 31 characters to be significant.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If two identifiers differ only in non-significant characters, the behaviour is undefined.<br/><br/>

If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in<br/>
The Standard.
<br/><br/>
Long identifiers may impair the readability of code. While many automatic code generation systems<br/>
produce long identifiers, there is a good argument for keeping identifier lengths well below this limit.<br/><br/>

Note: In C99, if an extended source character appears in an external identifier and that character does<br/>
not have a corresponding universal character, The Standard does not specify how many characters<br/>
it occupies.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_02</rule>
		<ruleTitle><![CDATA[Identifier s declared in the same scope and name space shall be distinct]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

This rule does not apply if both identifiers are external identifiers because this case is covered by<br/>
Rule 5.1.<br/><br/>

This rule does not apply if either identifier is a macro identifier because this case is covered by Rule 5.4<br/>
and Rule 5.5.<br/><br/>

The definition of distinct depends on the implementation and on the version of the C language that<br/>
is being used:<br/><br/>

• In C90 the minimum requirement is that the first 31 characters are significant;<br/><br/>

• In C99 the minimum requirement is that the first 63 characters are significant, with each<br/>
universal character or extended source character counting as a single character.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If two identifiers differ only in non-significant characters, the behaviour is undefined.<br/><br/>

If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in<br/>
The Standard.<br/><br/>

Long identifiers may impair the readability of code. While many automatic code generation systems<br/>
produce long identifiers, there is a good argument for keeping identifier lengths well below this limit.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 1.1, Rule 5.1, Rule 5.3, Rule 5.4, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_07</rule>
		<ruleTitle><![CDATA[A tag name shall be a unique identifier]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/>
<br />
The tag shall be unique across all name spaces and translation units.<br />
<br />
All declarations of the tag shall specify the same type.<br />
<br />
Multiple complete declarations of the same tag are only permitted by this rule if the tag is declared in<br />
a header file and that header file is included in multiple source files.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Reusing a tag name may lead to developer confusion.<br />
<br />
There is also undefined behaviour associated with reuse of tag names in C90 although this is not<br />
listed in The Standard&rsquo;s Annex. This undefined behaviour was recognized in C99 as a constraint in<br />
Section 6.7.2.3.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
The tag name may be the same as the typedef name with which it is associated.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 5.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_08</rule>
		<ruleTitle><![CDATA[Identifiers that define objects or functions with external linkage shall be unique]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/>
<br />
An identifier used as an external identifier shall not be used for any other purpose in any name space<br />
or translation unit, even if it denotes an object with no linkage.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Enforcing uniqueness of identifier names in this manner helps avoid confusion. Identifiers of objects<br />
that have no linkage need not be unique since there is minimal risk of such confusion.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 5.3<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_05</rule>
		<ruleTitle><![CDATA[Identifi ers shall be distinct from macro names]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule requires that the names of macros that exist prior to preprocessing be distinct from the<br />
identifiers that exist after preprocessing. It applies to identifiers, regardless of scope or name space,<br />
and to any macros that have been defined regardless of whether the definition is still in force when<br />
the identifier is declared.<br />
<br />
The definition of distinct depends on the implementation and the version of the C language that is<br />
being used:<br />
<br />
&bull; In C90 the minimum requirement is that the first 31 characters are significant;<br />
<br />
&bull; In C99 the minimum requirement is that the first 63 characters are significant, with each<br />
universal character or extended source character counting as a single character.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Keeping macro names and identifiers distinct can help to avoid developer confusion.<br /><br />

<span style="color:#B73232">See also</span> &nbsp;Rule 5.1, Rule 5.2, Rule 5.5<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_05_06</rule>
		<ruleTitle><![CDATA[A ty pedef name shall be a unique identifier]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/>
<br />
A typedef name shall be unique across all name space s and translation units. Multiple declarations of<br />
the same typedef name are only permitted by this rule if the type definition is made in a header file and<br />
that header file is included in multiple source files.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Reusing a typedef name either as another typedef name or as the name of a function, object or<br />
enumeration constant, may lead to developer confusion.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
The typedef name may be the same as the structure, union or enumeration tag name associated with<br />
the typedef.<br />
<br />
<span style="color:#B73232">See also</span> &nbsp;Rule 5.7<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_04</rule>
		<ruleTitle><![CDATA[There shall be no attempt to write to a stream which has been opened as read-only]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The Standard does not specify the behaviour if an attempt is made to write to a read-only stream. For<br />
this reason it is considered unsafe to write to a read-only stream.
<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_05</rule>
		<ruleTitle><![CDATA[A pointer to a FILE object shall not be dereferenced]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
A pointer to a FILE object shall not be dereferenced directly or indirectly (e.g. by a call to memcpy or<br />
memcmp).<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The Standard (C90 Section 7.9.3(6), C99 Section 7.19.3(6) ) states that the address of a FILE object<br />
used to control a stream may be significant and a copy of the object may not give the same behaviour.<br />
This rule ensures that such a copy cannot be made.<br />
<br />
The direct manipulation of a FILE object is prohibited as this may be incompatible with its use as a<br />
stream designator.

<br /><br />
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_06</rule>
		<ruleTitle><![CDATA[The value of a pointer to a FILE shall not be used after the associated stream has been closed]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
The Standard states that the value of a FILE pointer is indeterminate after a close operation on a<br />
stream.

<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.13, Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_01</rule>
		<ruleTitle><![CDATA[All resources obtained dynamically by means of Standard Library functions shall be explicitly released]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
The Standard Library functions that allocate resources are malloc, calloc, realloc and fopen.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
If resources are not explicitly released then it is possible for a failure to occur due to exhaustion of<br />
those resources. Releasing resources as soon as possible reduces the possibility that exhaustion will<br />
occur.

<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3, Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_02</rule>
		<ruleTitle><![CDATA[A block of memory shall only be freed if it was allocated by means of a Standard Library function]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
The Standard Library functions that allocate memory are malloc, calloc and realloc.<br />
<br />
A block of memory is freed when its address is passed to free and potentially freed when its address is<br />
passed to realloc. Once freed, a block of memory is no longer considered to be allocated and therefore<br />
cannot subsequently be freed again.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Freeing non-allocated memory, or freeing the same allocated memory more than once leads to<br />
undefined behaviour.

<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Dir 4.12, Dir 4.13, Rule 21.3<br/>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_22_03</rule>
		<ruleTitle><![CDATA[The same file shall not be open for read and write access at the same time on different streams]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to files opened with The Standard Library functions. It may also apply to similar<br />
features provided by the execution environment.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The Standard does not specify the behaviour if a file is both written and read via different streams.<br />
Note: it is acceptable to open a file multiple times for read-only access.

<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 21.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_03</rule>
		<ruleTitle><![CDATA[The lowercase character “l” shall not be used in a literal suffix]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>

Using the uppercase suffix “L” removes the potential ambiguity between “1” (digit 1) and “l” (letter “el”)
when declaring literals.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_04</rule>
		<ruleTitle><![CDATA[A string literal shall not be assigned to an object unless the object’s type is “pointer to const-qualified char”]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br/>
<br />
No attempt shall be made to modify a string literal or wide string literal directly.<br />
<br />
The result of the address-of operator, &amp;, applied to a string literal shall not be assigned to an object<br />
unless that object&rsquo;s type is &ldquo;pointer to array of const-qualified char&rdquo;.<br />
<br />
The same considerations apply to wide string literals. A wide string literal shall not be assigned to an<br />
object unless the object&rsquo;s type is &ldquo;pointer to const-qualifi ed wchar_t&rdquo;. The result of the address-of<br />
operator, &amp;, applied to a wide string literal shall not be assigned to an object unless that object&rsquo;s type<br />
is &ldquo;pointer to array of const-qualified wchar_t&rdquo;.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Any attempt to m odify a string literal results in undefi ned behaviour. For example, some<br />
implementations may store string literals in read-only memory in which case an attempt to modify<br />
the string literal will fail and may also result in an exception or crash.<br />
<br />
This rule, when applied in conjunction with others, prevents a string literal from being modified.<br />
<br />
It is explicitly unspecifi ed in C99 whether string literals that share a common ending are stored in<br />
distinct memory locations. Therefore, even if an attempt to modify a string literal appears to succeed,<br />
it is possible that another string literal might be inadvertently altered.
<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;Rule 11.4, Rule 11.8<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_02</rule>
		<ruleTitle><![CDATA[The initializer for an aggregate or union shall be enclosed in braces]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to initializers for both objects and subobjects.<br />
<br />
An initializer of the form { 0 }, which sets all values to 0, may be used to initialize subobjects without<br />
nested braces.<br />
<br />
Note: this rule does not itself require explicit initialization of objects or subobjects.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Using braces to indicate init ialization of subobjects improves the clarity of code and forces programmers<br />
to consider the initialization of elements in complex data structures such as multi-dimensional arrays<br />
or arrays of structures.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
1. An array may be initialized u sing a string literal.<br /><br/>
2. An automatic structure or union may be initialized using an expression with compatible<br />
structure or union type.<br /><br/>
3. A designated initializer may be used to initialize part of a subobject.<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_01</rule>
		<ruleTitle><![CDATA[The value of an object with automatic storage duration shall not be read before it has been set]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Mandatory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
For the purposes of this rule, an array element or structure member shall be considered as a discrete<br />
object.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
According to The Standard, objects with static storage duration are automatically initialized to zero<br />
unless initialized explicitly. Objects with automatic storage duration are not automatically initialized<br />
and can therefore have indeterminate values.<br />
<br />
Note: it is sometimes possible for the explicit initialization of an automatic object to be ignored. This<br />
will happen when a jump to a label using a goto or switch statement &ldquo;bypasses&rdquo; the declaration of the<br />
object; the object will be declared as expected but any explicit initialization will be ignored.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3<br>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_04</rule>
		<ruleTitle><![CDATA[An element of an object shall not be initialized more than once]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to initializers for both objects and subobjects.<br />
<br />
The provision of designated initializers in C99 allows the naming of the components of an aggregate<br />
(structure or array) or of a union to be initialized within an initializer list and allows the object&rsquo;s elements<br />
to be initialized in any order by specifying the array indices or structure member names they apply to<br />
(elements having no initialization value assume the default for uninitialized objects).<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Care is required when using de signated initializers since the initialization of object elements can be<br />
inadvertently repeated leading to overwriting of previously initialized elements. The C99 Standard<br />
does not specify whether the side eff ects in an overwritten initializer occur or not although this is not<br />
listed in Annex J.<br />
<br />
In order to allow sparse arrays and structures, it is acceptable to only initialize those which are<br />
necessary to the application.<br />
<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_03</rule>
		<ruleTitle><![CDATA[Arrays shall not be partially initialized]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
If any element of an array object or subobject is explicitly initialized, then the entire object or subobject<br />
shall be explicitly initialized.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Providing an explicit initial ization for each element of an array makes it clear that every element has<br />
been considered.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
1. An initializer of the form { 0 } may be used to explicitly initialize all elements of an array<br />
object or subobject.<br />
<br />
2. An array whose initializer consists only of designated initializers may be used, for example to<br />
perform a sparse initialization.<br />
<br />
3. An array initialized using a string literal does not need an initializer for every element.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_09_05</rule>
		<ruleTitle><![CDATA[Where designated initializers are used t o initialize an array object the size of the array shall be specified explicitly]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
The rule applies equally t o an array subobject that is a fl exible array member.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
If the size of an array is not specifi ed explicitly, it is determined by the highest index of any of the<br />
elements that are initialized. When using designated initializers it may not always be clear which<br />
initializer has the highest index, especially when the initializer contains a large number of elements.<br />
<br />
To make the intent clear, the array size shall be declared explicitly. This provides some protection<br />
if, during development of the program, the indices of the initialized elements are changed as it is a<br />
constraint violation (C99 Section 6.7.8) to initialize an element outside the bounds of an array.
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_02</rule>
		<ruleTitle><![CDATA[A “u” or “U” suffix shall be applied to all integer constants that are represented in an unsigned type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to:<br />
<br />
&bull; Integer constants that appear in the controlling expressions of #if and #elif preprocessing<br />
directives;<br />
<br />
&bull; Any other integer constants that exist after preprocessing.<br />
<br />
Note: during preprocessing, the type of an integer constant is determined in the same manner as after<br />
preprocessing except that:<br />
<br />
&bull; All signed integer types behave as if they were long (C90) or intmax_t (C99);<br />
<br />
&bull; All unsigned integer types behave as if they were unsigned long (C90) or uintmax_t (C99).<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
The type of an integer constant is a potential source of confusion, because it is dependent on a<br />
complex combination of factors including:<br />
<br />
&bull; The magnitude of the constant;<br />
<br />
&bull; The implemented sizes of the integer types;<br />
<br />
&bull; The presence of any suffixes;<br />
<br />
&bull; The number base in which the value is expressed (i.e. decimal, octal or hexadecimal).<br />
<br />
For example, the integer constant 40000 is of type signed int in a 32-bit environment but of type signed<br />
long in a 16-bit environment. The value 0x8000 is of type unsigned int in a 16-bit environment, but of<br />
type signed int in a 32-bit environment.<br />
<br />
Note:<br />
<br />
&bull; Any value with a &ldquo;U&rdquo; suffix is of unsigned type;<br />
<br />
&bull; An unsuffixed decimal value less than 231 is of signed type.<br />
<br />
&bull; An unsuffixed hexadecimal value greater than or equal to 215 may be of signed or unsigned<br />
type;<br />
<br />
&bull; For C90, an unsuffi xed decimal value greater than or equal to 231 may be of signed or unsigned<br />
type.<br />
<br />
Signedness of constants should be explicit. If a constant is of an unsigned type, applying a &ldquo;U&rdquo; suffix<br />
makes it clear that the programmer understands that the constant is unsigned.<br />
<br />
Note: this rule does not depend on the context in which a constant is used; promotion and other<br />
conversions that may be applied to the constant are not relevant in determining compliance with this<br />
rule.<br />
<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_07_01</rule>
		<ruleTitle><![CDATA[Octal constants shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/>
<br />
Developers writing constants that have a leading zero might expect them to be interpreted as decimal<br />
constants.<br />
<br />
Note: this rule does not apply to octal escape sequences because the use of a leading \ character<br />
means that there is less scope for confusion.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
The integer constant zero (written as a single numeric digit), is strictly speaking an octal constant, but<br />
is a permitted exception to this rule.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_01</rule>
		<ruleTitle><![CDATA[All switch statements shall be well-formed]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
A switch statement shall be considered to be well-formed if it conforms to the subset of C switch<br />
statements that is specified by the following syntax rules. If a syntax rule given here has the same<br />
name as one defined in The Standard then it replaces the standard version for the scope of the switch<br />
statement; otherwise, all syntax rules given in The Standard are unchanged.<br />
<br />
switch-statement:<br />
&nbsp;&nbsp;&nbsp;switch ( switch-expression ) { case-label-clause-list final-default-clause-list }<br />
&nbsp;&nbsp;&nbsp;switch ( switch-expression ) { initial-default-clause-list case-label-clause-list }<br />
<br />
case-label-clause-list:<br />
&nbsp;&nbsp;&nbsp; case-clause-list<br />
&nbsp;&nbsp;&nbsp; case-label-clause-list case-clause-list<br />
<br />
case-clause-list:<br />
&nbsp;&nbsp;&nbsp; case-label switch-clause<br />
&nbsp;&nbsp;&nbsp; case-label case-clause-list<br />
<br />
case-label:<br />
&nbsp;&nbsp;&nbsp; case constant-expression:<br />
<br />
final-default-clause-list:<br />
&nbsp;&nbsp;&nbsp; default: switch-clause<br />
&nbsp;&nbsp;&nbsp; case-label final-default-clause-list<br />
<br />
initial-default-clause-list:<br />
&nbsp;&nbsp;&nbsp; default: switch-clause<br />
&nbsp;&nbsp;&nbsp; default: case-clause-list<br />
<br />
switch-clause:<br />
&nbsp;&nbsp;&nbsp; statement-list opt break;<br />
&nbsp;&nbsp;&nbsp; C90: { declaration-list(opt) statement-list(opt) break; }<br />
&nbsp;&nbsp;&nbsp; C99: { block-item-list(opt) break; }<br />
<br />
Except where explicitly permitted by this syntax, the case and default keywords may not appear<br />
anywhere within a switch statement body.<br />
Note: some of the restrictions imposed on switch statements by this rule are expounded in the rules<br />
referenced in the &ldquo;See also&rdquo; section. It is therefore possible for code to violate both this rule and one<br />
of the more specific rules.<br />
Note: the term switch label is used within the text of the specific switch statement rules to denote<br />
either a case label or a default label.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The syntax for the switch statement in C is not particularly rigorous and can allow complex, unstructured<br />
behaviour. This and other rules impose a simple and consistent structure on the switch statement.<br />

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.3, Rule 16.2, Rule 16.3, Rule 16.4, Rule 16.5, Rule 16.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_02</rule>
		<ruleTitle><![CDATA[A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The Standard permits a switch label, i.e. a case label or default label, to be placed before any statement<br />
contained in the body of a switch statement, potentially leading to unstructured code. In order to<br />
prevent this, a switch label shall only appear at the outermost level of the compound statement<br />
forming the body of a switch statement.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_03</rule>
		<ruleTitle><![CDATA[An unconditional break statement shall terminate every switch-clause]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
If a developer fails to end a switch-clause with a break statement, then control fl ow &ldquo;falls&rdquo; into the<br />
following switch-clause or, if there is no such clause, off the end and into the statement following<br />
the switch statement. Whilst falling into a following switch-clause is sometimes intentional, it is often<br />
an error. An unterminated switch-clause occurring at the end of a switch statement may fall into any<br />
switch-clauses which are added later.<br />
<br />
To ensure that such errors can be detected, the last statement in every switch-clause shall be a break<br />
statement, or if the switch-clause is a compound statement, the last statement in the compound<br />
statement shall be a break statement.<br />
<br />
Note: a switch-clause is defined as containing at least one statement. Two consecutive labels, case or<br />
default, do not have any intervening statement and are therefore permitted by this rule.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_04</rule>
		<ruleTitle><![CDATA[Every switch statement shall have a default label]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
The switch-clause following the default label shall, prior to the terminating break statement, contain<br />
either:<br />
<br />
&bull; A statement, or<br />
<br />
&bull; A comment.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The requirement for a default label is defensive programming. Any statements following the default<br />
label are intended to take some appropriate action. If no statements follow the label then the comment<br />
can be used to explain why no specific action has been taken.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_05</rule>
		<ruleTitle><![CDATA[A default label shall appear as either the first or the last switch label of a switch statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br><br>
This rule makes it easy to locate the default label within a switch statement.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.7, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_06</rule>
		<ruleTitle><![CDATA[Every switch statement shall have at least two switch-clauses]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br><br>
A switch statement with a single path is redundant and may be indicative of a programming error.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_16_07</rule>
		<ruleTitle><![CDATA[A switch-expression shall not have essentially Boolean type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br><br>

The Standard requires the controlling expression of a switch statement to h ave an integer type. Since
t he type that is used to implement Boolean values is an integer, it is possible to have a switch statement
controlled by a Boolean expression. In this instance an if-else construct would be more appropriate.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies even if the expression containing the assignment operator is not evaluated.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The use of assignment operators, simple or compound, in combination with other arithmetic operators<br />
is not recommended because:<br />
<br />
&bull; It can significantly impair the readability of the code;<br />
<br />
&bull; It introduces additional side effects into a statement making it more difficult to avoid the<br />
undefined behaviour covered by Rule 13.2.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>
<br />
The evaluation of the right-hand operand of the &amp;&amp; and || operators is conditional on the value of the<br />
left-hand operand. If the right-hand operand contains side effects then those side effects may or may<br />
not occur which may be contrary to programmer expectations.<br />
<br />
If evaluation of the right-hand operand would produce side effects which are not persistent at the point<br />
in the program where the expression occurs then it does not matter whether the right-hand operand<br />
is evaluated or not.<br />
<br />
The term persistent side eff ect is defined in Appendix J.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_02</rule>
		<ruleTitle><![CDATA[The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
Between any two adjacent sequence points or within any full expression:<br />
<br />
1. No object shall be modified more than once;<br />
<br />
2. No object shall be both modified and read unless any such read of the object&rsquo;s value<br />
contributes towards computing the value to be stored into the object;<br />
<br />
3. There shall be no more than one modification access with volatile-qualified type;<br />
<br />
4. There shall be no more than one read access with volatile-qualified type.<br />
<br />
Note: An object might be accessed indirectly, by means of a pointer or a called function, as well as<br />
being accessed directly by the expression.<br />
<br />
Note: This Amplification is intentionally stricter than the headline of the rule. As a result, expressions<br />
such as:<br />
<br />
x = x = 0;<br />
<br />
are not permitted by this rule even though the value and the persistent side eff ects, provided that x is<br />
not volatile, are independent of the order of evaluation or side effects.<br />
<br />
Sequence points are summarized in Annex C of both the C90 and C99 standards. The sequence<br />
points in C90 are a subset of those in C99.<br />
<br />
Full expressions are defined in Section 6.6 of the C90 standard and Section 6.8 of the C99 standard.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The Standard gives con siderable fl exibility to compilers when evaluating expressions. Most operators<br />
can have their operands evaluated in any order. The main exceptions are:<br />
<br />
&bull; Logical AND &amp;&amp; in which the second operand is evaluated only if the fi rst operand evaluates<br />
to non-zero;<br />
<br />
&bull; Logical OR || in which the second operand is evaluated only if the fi rst operand evaluates to<br />
zero;<br />
<br />
&bull; The conditional operator ?: in which the fi rst operand is always evaluated and then either the<br />
second or third operand is evaluated;<br />
<br />
&bull; The , operator in which the fi rst operand is evaluated and then the second operand is<br />
evaluated.<br />
<br />
Note: The presence of parentheses may alter the order in which operators are applied. However, this<br />
does not affect the order of evaluation of the lowest-level operands, which may be evaluated in any<br />
order.<br />
<br />
Many of the common instances of the unpredictable behaviour associated with expression evaluation<br />
can be avoided by following the advice given by Rule 13.3 and Rule 13.4.<br />


<br/><br/><span style="color:#B73232">See also</span>&nbsp;Dir 4.9, Rule 13.0, Rule 13.3, Rule 13.4<br/>]]></ruleDesc>
		<ruleSeverity>Other</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_03</rule>
		<ruleTitle><![CDATA[A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
A function call is considered to be a side effect for the purposes of t his rule.<br />
<br />
All sub-expressions of the full expression are treated as if they were evaluated for the purposes of this<br />
rule, even if specified as not being evaluated by The Standard.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The use of increment and decrement operators in combination with other operators is not<br />
recommended because:<br />
<br />
&bull; It can significantly impair the readability of the code;<br />
<br />
&bull; It introduces additional side effects into a statement with the potential for undefined behaviour<br />
(covered by Rule 13.2).<br />
<br />
It is clearer to use these operations in isolation from any other operators.</br></br>
<span style="color:#B73232">See also</span>&nbsp;Rule 13.2</br>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_01</rule>
		<ruleTitle><![CDATA[Initializer lists shall not contain persistent side effects]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C99</br></br>


<span style="color:#B73232">Rationale</span><br>

<br />
C90 cons trains the initializers for automatic objects with aggregate types to contain only constant<br />
expressions. However, C99 permits automatic aggregate initializers to contain expressions that are<br />
evaluated at run-time. It also permits compound literals which behave as anonymous initialized<br />
objects. The order in which side effects occur during evaluation of the expressions in an initializer list<br />
is unspecified and the behaviour of the initialization is therefore unpredictable if those side effects are<br />
persistent.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 13.2<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_13_06</rule>
		<ruleTitle><![CDATA[The operand of the sizeof operator shall not contain any expression which has potential side effects]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
Any expressions appearing in the operand of a sizeof operator are not normally evaluated. This rule<br />
mandates that the evaluation of any such expression shall not contain side effects, whether or not it is<br />
actually evaluated.<br />
<br />
A function call is considered to be a side effect for the purposes of this rule.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The operand of a sizeof operator may be either an expression or may specify a type. If the operand<br />
contains an expression , a possible programming error is to expect that expression to be evaluated<br />
when it is actually not evaluated in most circumstances.<br />
<br />
The C90 standard states that expressions appearing in the operand are not evaluated at run-time.<br />
<br />
In C99, expressions appearing in the operand are usually not evaluated at run-time. However, if the<br />
operand contains a variable-length array type then the array size expression will be evaluated if necessary. If the result can be determined without evaluating the array size expression then it is<br />
unspecified whether it is evaluated or not.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
An expression of the form sizeof ( V ), where V is an lvalue with a volatile qualified type that is not<br />
a variable-length array, is permitted.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 18.8</br>]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_05</rule>
		<ruleTitle><![CDATA[A project should not contain unused macro declarations]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If a macro is declared but n ot used, then it is unclear to a reviewer if the macro is redundant or it has<br/>
been left unused by mistake.<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_04</rule>
		<ruleTitle><![CDATA[A project should not contain unused tag declarations]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If a tag is declared but not used, then it is unclear to a reviewer if the tag is redundant or it has been<br/>
left unused by mistake.<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_03</rule>
		<ruleTitle><![CDATA[A project should not contain unused type declarations]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If a type is declared but no t used, then it is unclear to a reviewer if the type is redundant or it has been<br/>
left unused by mistake.<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_02</rule>
		<ruleTitle><![CDATA[There shall be no dead code]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

Any operation that is executed but whose removal would not aff ect program behaviour constitutes<br/>
dead code. Operations that are introduced by language extensions are assumed always to have an<br/>
effect on program behaviour.<br/><br/>

Note: The behaviour of an embedded system is often determined not just by the nature of its actions,<br/>
but also by the time at which they occur.<br/><br/>

Note: unreachable code is not dead code as it cannot be executed.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

The presence of dead code may be indicative of an error in the program’s logic. Since dead code may<br/>
be removed by a compiler, its presence may cause confusion.<br/><br/>

<span style="color:#B73232">Exception</span><br/><br/>

A cast to void is assumed to indicate a value that is intentionally not being used. The cast is therefore<br/>
not dead code itself. It is treated as using its operand which is therefore also not dead code.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 17.7<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_01</rule>
		<ruleTitle><![CDATA[A project shall not contain unreachable code]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

Provided that a program does not exhibit any undefined behaviour, unreachable code cannot be<br/>
executed and cannot have any effect on the program’s outputs. The presence of unreachable code<br/>
may therefore indicate an error in the program’s logic.<br/><br/>

A compiler is permitted to remove any unreachable code although it does not have to do so. Unreachable<br/>
code that is not removed by the compiler wastes resources, for example:<br/><br/>

• It occupies space in the target machine’s memory;<br/><br/>

• Its presence may cause a compiler to select longer, slower jump instructions when transferring<br/>
control around the unreachable code;<br/><br/>

• Within a loop, it might prevent the entire loop from residing in an instruction cache.<br/><br/>

It is sometimes desirable to insert code that appears to be unreachable in order to handle exceptional<br/>
cases. For example, in a switch statement in which every possible value of the controlling expression<br/>
is covered by an explicit case, a default clause shall be present according to Rule 16.4. The purpose of<br/>
the default clause is to trap a value that should not normally occur but that may have been generated<br/>
as a result of:<br/><br/>

• Undefined behaviour present in the program;<br/><br/>

• A failure of the processor hardware.<br/><br/>

If a compiler can prove that a default clause is unreachable, it may remove it, thereby eliminating the<br/>
defensive action. On the assumption that the defensive action is important, it will be necessary either<br/>
to demonstrate that the compiler does not eliminate the code despite it being unreachable, or to<br/>
take steps to make the defensive code reachable. The former course of action requires a deviation<br/>
against this rule, probably with a review of the object code or unit testing being used to support such<br/>
a deviation. The latter course of action can usually be achieved by means of a volatile access. For<br/>
example, a compiler might determine that the range of values held by x is covered by the case clauses<br/>
in a switch statement such as:<br/><br/>

uint16_t x;<br/><br/>

switch ( x )<br/><br/>

By forcing x to be accessed by means of a volatile qualified lvalue, the compiler has to assume that the<br/>
controlling expression could take any value:<br/><br/>

switch ( *( volatile uint16_t * ) &x )<br/><br/>

Note: code that has been conditionally excluded by pre-processor directives is not subject to this rule<br/>
as it is not presented to the later phases of translation.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Rule 14.3, Rule 16.4<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_07</rule>
		<ruleTitle><![CDATA[There should be no unused parameters in functions]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>

Most functions will be specified as using each of their parameters. If a function parameter is unused,<br/>
it is possible that the implementation of the function does not match its specification. This rule<br/>
highlights such potential mismatches.<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_02_06</rule>
		<ruleTitle><![CDATA[A function should not contain unused label declarations]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>

If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has<br/>
been left unused by mistake.<br/>/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_04_01</rule>
		<ruleTitle><![CDATA[Octal and hex adecimal escape sequences shall be terminated]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br/><br/>

An octal or hexadecimal escape sequence shall be terminated by either:<br/><br/>

• The start of another escape sequence, or<br/><br/>

• The end of the character constant or the end of a string literal.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

There is potential for confusion if an oct al or hexadecimal escape sequence is followed by other<br/>
characters. For example, the character constant '\x1f' consists of a single character whereas the<br/>
character constant '\x1g' consists of the two characters '\x1' and 'g'. The manner in which<br/>
multi-character constants are represented as integers is implementation-defined.<br/><br/>

The potential for confusion is reduced if every octal or hexadecimal escape sequence in a character<br/>
constant or string literal is terminated.<br/><br/>
<span style="color:#B73232">See also</span> &nbsp;C90: Section 6.1.3.4, C99: Section 6.4.4.4<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_04_02</rule>
		<ruleTitle><![CDATA[Trigraphs should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

Trigraphs are denoted by a sequence of two question marks followed by a specified third character<br/>
(e.g. ??- represents a ~ (tilde) character and ??) represents a ] ). They can cause accidental confusion<br/>
with other uses of two question marks.<br/><br/>

Note: the so-called digraphs:<br/><br/>

<: :> <% %> %: %:%:<br/><br/>

are permitted because they are tokens. Trigraphs are replaced wherever they appear in the program<br/>
prior to preprocessing.<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
The body of an iteration-statement (while, do &#8230; while or for) or a selection -statement (if, else, switch) shall<br />
be a compound-statement.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
It is possible for a developer to mistakenly believe that a sequence of statements forms the body of<br />
an iteration -statement or selection-statement by virtue of their indentation. The accidental inclusion of a<br />
semi-colon after the controlling expression is a particular danger , leading to a null control statement.<br />
Using a compound-statement clearly defines which statements actually form the body.<br />
<br />
Additionally, it is possible that indentation may lead a developer to associate an else statement with<br />
the wrong if.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
An if statement immediately following an else need not be contained within a compound-statement.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_07</rule>
		<ruleTitle><![CDATA[All if … else if constructs shall be terminated with an else statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
A final else statement shall always be provided whenever an if statement is followed by a sequence<br />
of one or more else if constructs. The else statement shall contain at least either one side effect or a<br />
comment.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Terminating a sequence of if &#8230; else if constructs with an else statement is defensive programming and<br />
complements the requirement for a default clause in a switch statement (see Rule 16.5).<br />
<br />
The else statement is required to have a side effect or a comment to ensure that a positive indication is<br />
given of the desired behaviour, aiding the code review process.<br />
<br />
Note: a fi nal else statement is not required for a simple if statement.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 16.5<br/>
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_04</rule>
		<ruleTitle><![CDATA[There should be no more than one break or goto statement used to terminate any iteration statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
Restricting the number of exits from a loop helps to minimize visual code complexity. The use of one<br />
break or goto statement allows a single secondary exit path to be created when early loop termination<br />
is required.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.2, Rule 15.3<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[function should have a single point of exit at the end]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
A function should have no more than one return statement.<br />
<br />
When a return statement is used, it should be the final statement in the compound statement that<br />
forms the body of the function.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
A single point of exit is required by IEC 61508 and IS O 26262 as part of the requirements for a modular<br />
approach.<br />
<br />
Early returns may lead to the unintentional omission of function termination code.<br />
<br />
If a function has exit points interspersed with statements that produce persistent side effects, it is not<br />
easy to determine which side effects will occur when the function is executed.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 17.4<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_02</rule>
		<ruleTitle><![CDATA[The goto statement shall jump to a label declared later in the same function]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>
<br />
Unconstrained use of goto can lead to programs that are unstructured and extremely difficult to<br />
understand.<br />
<br />
Restricting the use of goto so that &ldquo;back&rdquo; jumps are prohibited ensures that iteration only occurs if the<br />
iteration statements provided by the language are used, helping to minimize visual code complexity.<br />

 <br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 15.1, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_03</rule>
		<ruleTitle><![CDATA[Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
For the purposes of this rule, a switch-clause that does not consist of a compound statement is treated<br />
as if it were a block.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Unconstrained use of goto can lead to programs that are unstructured and extremely difficult to<br />
understand.<br />
<br />
Preventing jumps between blocks, or into nested blocks, helps to minimize vi sual code complexity.<br />
Note: C99 is more restrictive when variably modified types are used. An attempt to make a jump from<br />
outside the scope of an identifier with a variably modified type into such a scope results in a constraint<br />
violation.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.1, Rule 15.2, Rule 15.4, Rule 16.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_15_01</rule>
		<ruleTitle><![CDATA[The goto statement should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>
<br />
Unconstrained use of goto can lead to programs that are unstructured and extremely difficult to<br />
under stand.<br />
<br />
In some cases a total ban on goto requires the introduction of fl ags to ensure correct control fl ow,<br />
and it is possible that these flags may themselves be less transparent than the goto they replace.<br />
Therefore, if this rule is not followed, the restricted use of goto is allowed where that use follows the<br />
guidance in Rule 15.2 and Rule 15.3.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 9.1, Rule 15.2, Rule 15.3, Rule 15.4</br>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_01</rule>
		<ruleTitle><![CDATA[A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
Creation of a pointer to one beyond the end of the array is well-defined by The Standard and is<br />
permitted by this rule. Dereferencing a pointer to one beyond the end of an array results in undefined<br />
behaviour and is forbidden by this rule.<br />
<br />
This rule applies to all forms of array indexing:<br />
<br />
integer_expression + pointer_expression<br />
pointer_expression + integer_expression<br />
pointer_expression - integer_expression<br />
pointer_expression += integer_expression<br />
pointer_expression -= integer_expression<br />
++pointer_expression<br />
pointer_expression++<br />
--pointer_expression<br />
pointer_expression--<br />
pointer_expression [ integer_expression ]<br />
integer_expression [ pointer_expression ]<br />
<br />
Note: a subarray is also an array.<br />
<br />
Note: for purposes of pointer arithmetic, The Standard treats an object that is not a member of an<br />
array as if it were an array with a single element (C90 Section 6.3.6, C99 Section 6.5.6).<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Although some compilers may be able to determine at compile time that an array boundary has been<br />
exceeded, no checks are generally made at run-time for invalid array subscripts. Using an invalid array<br />
subscript can lead to erroneous behaviour of the program.<br />
<br />
Run-time derived array subscript values are of the most concern since they cannot easily be checked<br />
by static analysis or manual review. Code of a defensive programming nature should, where possible<br />
and practicable, be provided to check such subscript values against valid ones and, if required,<br />
appropriate action be taken.<br />
It is undefined behaviour if the result obtained from one of the above expressions is not a pointer to<br />
an element of the array pointed to by pointer_expression or an element one beyond the end of<br />
that array. See C90 Section 6.3.6 and C99 Section 6.5.6 for further information.<br />
<br />
Multi-dimensional arrays are &ldquo;arrays of arrays&rdquo;. This rule does not allow pointer arithmetic that results<br />
in the pointer addressing a diff erent subarray. Array subscripting over &ldquo;internal&rdquo; boundaries shall not<br />
be used, as such behaviour is undefined.<br />


<br />
<span style="color:#B73232">See also</span>&nbsp;Dir 4.1,&nbsp;Rule 18.4<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_02</rule>
		<ruleTitle><![CDATA[Subtraction between pointers shall only be applied to pointers that address elements of the same array]]></ruleTitle>
		<ruleDesc><![CDATA[
<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
This rule applies to expressions of the form:<br />
<br />
pointer_expression_1 - pointer_expression_2<br />
<br />
It is undefined behaviour if pointer_expression_1 and pointer_expression_2 do not point to<br />
elements of the same array or the element one beyond the end of that array.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_08</rule>
		<ruleTitle><![CDATA[Variable-length array types shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
Variable-length array types are specified when the size of an array declared in a block or a function<br />
prototype is not an integer constant expression. They are typically implemented as a variable size object<br />
stored on the stack. Their use can therefore make it impossible to determine statically the amount of<br />
memory that must be reserved for a stack.<br />
<br />
If the size of a variable-length array is negative or zero, the behaviour is undefined.<br />
<br />
If a variable-length array is used in a context in which it is required to be compatible with another<br />
array type, possibly itself variable-length, then the size of the array types shall be identical. Further, all<br />
sizes shall evaluate to positive integers. If these requirements are not met, the behaviour is undefined.<br />
<br />
If a variable-length array type is used in the operand of a sizeof operator, under some circumstances<br />
it is unspecified whether the array size expression is evaluated or not.<br />
<br />
Each instance of a variable-length array type has its size fixed at the start of its lifetime. This gives rise<br />
to behaviour that might be confusing, for example:
<br/><br/>
<textarea id="ex1" >
void f ( int_16_t n )
{
	uint16_t vla[ n ];		/* Not-compliant - Undefined if n <= 0 */
}

void g ( void )
{
	f ( 0 );	/* Undefined */
	f ( -1 );	/* Undefined */
	f ( 10 );	/* Defined */
}

void h ( uint16_t n, uint16_t a[ 10 ][ n ] )		/* Non-compliant */
{
	uint16_t ( *p )[ 20 ];
	/* Undefined unless n == 20: incompatible types otherwise */
	p = a;
}
</textarea>
<script>CodeMirror.fromTextArea(document.getElementById('ex1'));</script><br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 13.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_07</rule>
		<ruleTitle><![CDATA[Flexible array members shall not be declared]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
Flexible array members are most likely to be used in conjunction with dynamic memory allocation<br />
which is banned by Dir 4.12 and Rule 21.3.<br />
<br />
The presence of flexible array members modifies the behaviour of the sizeof operator in ways that<br />
might not be expected by a programmer. The assignment of a structure that contains a flexible array<br />
member to another structure of the same type may not behave in the expected manner as it copies<br />
only those elements up to but not including the start of the flexible array member.

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Dir 4.12,&nbsp;Rule 21.3<br/>
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_06</rule>
		<ruleTitle><![CDATA[The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
The address of an object might be copied by means of:<br />
<br />
&bull; Assignment;<br />
<br />
&bull; Memory move or copying functions.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The address of an object becomes indeterminate when the lifetime of that object expires. Any use of<br />
an indeterminate address results in undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_05</rule>
		<ruleTitle><![CDATA[Declarations should contain no more than two levels of pointer nesting]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
No more than two pointer declarators should be applied consecutively to a type. Any typedef-name<br />
appearing in a declaration is treated as if it were replaced by the type that it denotes.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The use of more than two levels of pointer nesting can seriously impair the ability to understand the<br />
behaviour of the code, and should therefore be avoided.<br />
<br />

]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
Array indexing using the array subscript syntax , ptr[expr], is the preferred form of pointer arithmetic<br />
because it is often clearer and hence less error prone than pointer manipulation. Any explicitly<br />
calculated pointer value has the potential to access unintended or invalid memory addresses. Such<br />
behaviour is also possible with array indexing, but the subscript syntax may ease the task of manual<br />
review.<br />
<br />
Pointer arithmetic in C can be confusing to the novice. The expression ptr+1 may be mistakenly<br />
interpreted as the addition of 1 to the address held in ptr. In fact the new memory address depends<br />
on the size in bytes of the pointer&rsquo;s target. This misunderstanding can lead to unexpected behaviour<br />
if sizeof is applied incorrectly.<br />
<br />
When used with caution however, pointer manipulation using ++ can in some cases be considered<br />
more natural; e.g. sequentially accessing locations during a memory test where it is more convenient<br />
to treat the memory space as a contiguous set of locations and the address bounds can be determined<br />
at compilation time.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
Subject to Rule 18.2, pointer subtraction between two pointers is allowed.

<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 18.1,&nbsp;Rule 18.2<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_18_03</rule>
		<ruleTitle><![CDATA[The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
Attempting to make comparisons between pointers will produce undefined behaviour if the two<br />
pointers do not point to the same object.<br />
<br />
Note: it is permissible to address the next element beyond the end of an array, but accessing this<br />
element is not allowed.

<span style="color:#B73232">See also</span>&nbsp;Dir 4.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_06_02</rule>
		<ruleTitle><![CDATA[Single-bit named bit fields shall not be of a signed type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/>
<br />
According to the C99 Standard Section 6.2.6.2, a single-bit signed bit-field has a single (one) sign bit<br />
and no (zero) value bits. In any representation of integers, 0 value bits cannot specify a meaningful<br />
value.<br />
<br />
A single-bit signed bit-field is therefore unlikely to behave in a useful way and its presence is likely to<br />
indicate programmer confusion.<br />
<br />
Although the C90 Standard does not provide so much detail regarding the representation of types,<br />
the same considerations apply as for C99.<br />
<br />
Note: this rule does not apply to unnamed bit fi elds as their values cannot be accessed.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_06_01</rule>
		<ruleTitle><![CDATA[Bit-fields shall only be declared with an appropriate type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br/>
<br />
The appropriate bit-field types are:<br />
<br />
&bull; C90: either unsigned int or signed int;<br />
<br />
&bull; C99: one of:<br />
<br />
- either unsigned int or signed int;<br />
<br />
- another explicitly signed or explicitly unsigned integer type that is permitted by the<br />
implementation;<br />
<br />
- _Bool.<br />
<br />
Note: It is permitted to use typedefs to designate an appropriate type.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Using int is implementation-defined because bit-fields of type int can be either signed or unsigned .<br />
<br />
The use of enum, short, char or any other type for bit-fields is not permitted in C90 because the<br />
behaviour is undefined.<br />
<br />
In C99, the implementation may define other integer types that are permitted in bit-field declarations.<br />
<br />
<br />]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_01</rule>
		<ruleTitle><![CDATA[The features of <stdarg.h> shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
None of va_list, va_arg, va_start, va_end and, for C99, va_copy shall be used.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The Standard lists many instances of undefined behaviour associated with the features of<br />
stdarg.h, including:<br />
<br />
&bull; va_end not being used prior to end of a function in which va_start was used;<br />
<br />
&bull; va_arg being used in different functions on the same va_list;<br />
<br />
&bull; The type of an argument not being compatible with the type specified to va_arg.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_05</rule>
		<ruleTitle><![CDATA[The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
If a parameter is declared as an array with a specified size, the corresponding argument in each<br />
function call should point into an object that has at least as many elements as the array.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The use of an array declarator for a function parameter specifi es the f unction interface more clearly<br />
than using a pointer. The minimum number of elements expected by the function is explicitly stated,<br />
whereas this is not possible with a pointer.<br />
<br />
A function parameter array declarator which does not specify a size is assumed to indicate that the<br />
function can handle an array of any size. In such cases, it is expected that the array size will be<br />
communicated by some other means, for example by being passed as another parameter, or by<br />
terminating the array with a sentinel value.<br />
<br />
The use of an array bound is recommended as it allows out-of-bounds checking to be implemented<br />
within the function body and extra checks on parameter passing. It is legal in C to pass an array of the<br />
incorrect size to a parameter with a specified size, which can lead to unexpected behaviour.<br />
]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_04</rule>
		<ruleTitle><![CDATA[All exit paths from a function with non-void return type shall have an explicit return statement with an expression]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The expression given to the return statement provides the value that the function returns. If a non-void<br />
function does not return a value but the calling function uses the returned value, the behaviour<br />
is undefined. This can be avoided by ensuring that, in a non-void function:<br />
<br />
&bull; Every return statement has an expression, and<br />
<br />
&bull; Control cannot reach the end of the function without encountering a return statement.<br />
<br />
Note: C99 constrains every return statement in a non-void function to return a value.<br />
<br />
]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_03</rule>
		<ruleTitle><![CDATA[A function shall not be declared implicitly]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
Provided that a function call is made in the presence of a prototype, a constraint ensures that the<br />
number of arguments matches the number of parameters and that each argument can be assigned<br />
to its corresponding parameter.<br />
<br />
If a function is declare d implicitly, a C90 compiler will assume that the function has a return type of int.<br />
<br />
Since an implicit function declaration does not provide a prototype, a compiler will have no information<br />
about the number of function parameters and their types. Inappropriate type conversions may result<br />
in passing the arguments and assigning the return value, as well as other undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_02</rule>
		<ruleTitle><![CDATA[Functions shall not call themselves, either directly or indirectly]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>

Recursion carries with it the danger of exceeding available stack space, which can lead to a serious
failure. Unless recursion is very tightly controlled, it is not possible to determine before execution
what the worst-case stack usage could be.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
A function parameter behaves in the same manner as an object that has automatic storage duration.<br />
While the C language permits parameters to be modified, such use can be confusing and conflict with<br />
programmer expectations. It may be less confusing to copy the parameter to an automatic object<br />
and modify that copy. With a modern compiler, this will not usually result in any storage or execution<br />
time penalty.<br />
<br />
Programmers who are unfamiliar with C, but who are used to other languages, may modify a parameter<br />
believing that the effects of the modification will be felt in the calling function.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating Rule 2.2.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_17_06</rule>
		<ruleTitle><![CDATA[The declaration of an array parameter shall not contain the static keyword between the [ ]]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Mandatory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The C99 language standard provides a mechanism for the programmer t o inform the compiler that a n<br />
array parameter contains a specified minimum number of elements. Some compilers are able to take<br />
advantage of this information to generate more efficient code for some types of processor .<br />
<br />
If the guarantee made by the programmer is not honoured, and the number of elements is less than<br />
the minimum specified, the behaviour is undefined.<br />
<br />
The processors used in typical embedded applications are unlikely to provide the facilities required<br />
to take advantage of the additional information provided by the programmer. The risk of the program<br />
failing to meet the guaranteed minimum number of elements outweighs any potential performance<br />
increase.]]></ruleDesc>
		<ruleSeverity>Critical</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_01</rule>
		<ruleTitle><![CDATA[Types shall be explicitly specified]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
The C90 standard permits types to be omitted in some circumstances, in which case the int type is<br />
implicitly specified. Examples of the circumstances in which an implicit int might be used are:<br />
<br />
&bull; Object declarations;<br />
<br />
&bull; Parameter declarations;<br />
<br />
&bull; Member declarations;<br />
<br />
&bull; typedef declarations;<br />
<br />
&bull; Function return types.<br />
<br />
The omission of an explicit type might lead to confusion. For example, in the declaration:<br />
<br />
extern void g ( char c, const k );<br />
<br />
the type of k is const int whereas const char might have been expected.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
The early version of C, commonly referred to as K&amp;R C [30], did not provide a mechanism for checking<br />
the number of arguments or their types against the corresponding parameters. The type of an object<br />
or function did not have to be declared in K&amp;R C since the default type of an object and the default<br />
return type of a function was int.<br />
<br />
The C90 standard introduced function prototypes, a form of function declarator in which the<br />
parameter types were declared. This permitted argument types to be checked against parameter<br />
types. It also allowed the number of arguments to be checked except when a function prototype<br />
specifi ed that a variable number of arguments was expected. The C90 standard did not require the<br />
use of function prototypes for reasons of backward compatibility with existing code. For the same<br />
reason, it continued to permit types to be omitted in which case the type would default to int.<br />
<br />
The C99 standard removed the default int type from the language but continued to allow K&amp;R-style<br />
function types in which there was no means to supply parameter type information in a declaration<br />
and it was optional to supply parameter type information in a definition.<br />
<br />
The mismatch between the number of arguments and parameters, their types and the expected and<br />
actual return type of a function provides potential for undefi ned behaviour. The purpose of this rule<br />
along with Rule 8.1 and Rule 8.4 is to avoid this undefi ned behaviour by requiring parameter types and<br />
function return types to be specified explicitly. Rule 17.3 ensures that this information is available at<br />
the time of a function call, thereby requiring the compiler to diagnose any mismatch that is detected.<br />
<br />
This rule also requires that names be specified for all the parameters in a declaration. The parameter<br />
names can provide useful information regarding the function interface and a mismatch between a<br />
declaration and definition might be indicative of a programming error.<br />
<br />
Note: An empty parameter list is not valid in a prototype. If a function type has no parameters its<br />
prototype form uses the keyword void.<br />
<br />

Related link: <a href="http://david.tribble.com/text/cdiffs.htm#C99-empty-parm">http://david.tribble.com/text/cdiffs.htm#C99-empty-parm</a><br>

<br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.1, Rule 8.4, Rule 17.3<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_03</rule>
		<ruleTitle><![CDATA[All declarations of an object or function shall use the same names and type qualifiers]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
Storage class specifiers are not included within the scope of this rule.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Using types and qualifiers consistently across declarations of the same object or function encourages<br />
stronger typing.<br />
<br />
Specifying parameter names in function prototypes allows the function definition to be checked for<br />
interface consistency with its declarations.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
Compatible versions of the same basic type may be used interchangeably. For example, int, signed and<br />
signed int are all equivalent.<br />
<br />

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_01</rule>
		<ruleTitle><![CDATA[#include directives should only be preceded by preprocessor directives or comments]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
The rule shall be applied to the contents of a file before preprocessing occurs.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
To aid code readability, all the #include directives in a particular code file should be grouped together<br />
near the top of the file.<br />
<br />
Additionally, using #include to include a standard header file within a declaration or definition, or using<br />
part of The Standard Library before the inclusion of the related standard header file leads to undefined<br />
behaviour.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_03</rule>
		<ruleTitle><![CDATA[The #include dire ctive shall be followed by either a &lt;filename&gt; or &quot;filename&quot; sequence]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies after macro replacement has been performed.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The beh aviour is undefined if a #include directive does not use one of the following forms:<br /><br />
&bull; #include &lt;filename&gt;<br /><br />
&bull; #include &quot;filename&quot;]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_05</rule>
		<ruleTitle><![CDATA[An external object or function shall be declared once in one and only one file]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to non-defining declarations only.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Typically, a single declaration will be made in a header file that will be included in any translation unit in<br />
which the identifier is defined or used. This ensures consistency between:<br />
<br />
&bull; The declaration and the definition;<br />
<br />
&bull; Declarations in different translation units.<br />
<br />
Note: there may be many header files in a project, but each external object or function shall only be<br />
declared in one header file.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.4<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_02</rule>
		<ruleTitle><![CDATA[The ', " or \ characters and the /* or // character sequences shall not occur in a header file name]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
The behaviour is undefined if:<br />
<br />
&bull; The ', &quot; or \ characters, or the /* or // character sequences are used between < and ><br />
delimiters in a header name preprocessing token;<br />
<br />
&bull; The ' or \ characters, or the /* or // character sequences are used between the &quot; delimiters<br />
in a header name preprocessing token.<br />
<br />
Note: although use of the \ character results in undefined behaviour, many implementations will<br />
accept the / character in its place.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[A compatible declaration shall be visible when an object or function with external linkage is defined]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
A compatible declaration is one which declares a compatible type for the object or function being<br />
defined.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
If a declaration for an object or function is visible when that object or function is defi ned, a compiler<br />
must check that the declaration and definition are compatible. In the presence of function prototypes,<br />
as required by Rule 8.2, checking extends to the number and type of function parameters.<br />
<br />
The recommended method of implementing declarations of objects and functions with external<br />
linkage is to declare them in a header file, and then include the header file in all those code files that<br />
need them, including the one that defines them (See Rule 8.5).
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 8.2, Rule 8.3, Rule 8.5, Rule 17.3<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_05</rule>
		<ruleTitle><![CDATA[#undef should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
The use of #undef can make it unclear which macros exist at a particular point within a translation<br />
unit.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[Functions and objects should not be defined with external linkage if they are referenced in only one translation unit]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
Restricting the visibility of an object by giving it internal linkage or no linkage reduces the chance that<br />
it might be accessed inadvertently. Similarly, reducing the visibility of a function by giving it internal<br />
linkage reduces the chance of it being called inadvertently.<br />
<br />
Compliance with this rule also avoids any possibility of confusion between an identifier and an identical<br />
identifier in another translation unit or a library.<br />
]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_04</rule>
		<ruleTitle><![CDATA[A macro shall not be defined with the same name as a keyword]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to all keywords, including those that implement language extensions.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Using macros to change the meaning of keywords can be confusing. The behaviour is undefined if a<br />
standard header is included while a macro is defined with the same name as a keyword.
<br /><br />
<span style="color:#B73232">See also</span>&nbsp;Rule 21.1<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_06</rule>
		<ruleTitle><![CDATA[An identifier with external linkage shall have exactly one external definition]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
The behaviour is undefined if an identifier is used for which multiple definitions exist (in different files)<br />
or no definition exists at all. Multiple definitions in different files are not permitted by this rule even<br />
if the definitions are the same. It is undefined behaviour if the declarations are different, or initialize<br />
the identifier to different values.<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_07</rule>
		<ruleTitle><![CDATA[Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
If the expansion of any macro parameter produces a token, or sequence of tokens, that form an<br />
expression then that expression, in the fully-expanded macro, shall either:<br />
<br />
&bull; Be a parenthesized expression itself; or<br />
<br />
&bull; Be enclosed in parentheses.<br />
<br />
Note: this does not necessarily require that all macro parameters are parenthesized; it is acceptable<br />
for parentheses to be provided in macro arguments.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
If parentheses are not used, then operator precedence may not give the desired results when macro<br />
substitution occurs.<br />
<br />
If a macro parameter is not being used as an expression then the parentheses are not necessary<br />
because no operators are involved.<br />]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_09</rule>
		<ruleTitle><![CDATA[An object should be defined at block scope if its identifier only appears in a single function]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
Defining an object at block scope reduces the possibility that the object might be accessed inadvertently<br />
and makes clear the intention that it should not be accessed elsewhere.<br />
<br />
Within a function, whether objects are defined at the outermost or innermost block is largely a matter<br />
of style.<br />
<br />
It is recognized that there are situations in which it may not be possible to comply with this rule. For<br />
example, an object with static storage duration declared at block scope cannot be accessed directly<br />
from outside the block. This makes it impossible to set up and check the results of unit test cases<br />
without using indirect accesses to the object. In this kind of situation, some projects may prefer not<br />
to apply this rule.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_06</rule>
		<ruleTitle><![CDATA[Tokens that look like a preprocessing directive shall not occur within a macro argument]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
An argument containing sequences of tokens that would otherwise act as preprocessing directives<br />
leads to undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_08</rule>
		<ruleTitle><![CDATA[The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
Since definitions are also declarations, this rule applies equally to definitions.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
The Standard states that if an object or function is declared with the extern storage class specifier<br />
and another declaration of the object or function is already visible, the linkage is that specified by the<br />
<br />
earlier declaration. This can be confusing because it might be expected that the extern storage class<br />
specifier creates external linkage. The static storage class specifier shall therefore be consistently<br />
applied to objects and functions with internal linkage.<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_09</rule>
		<ruleTitle><![CDATA[All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
As well as using a #define pr eprocessor directive, identifiers may effectively be #define&rsquo;d in other,<br />
implementation-defined, ways. For example some implementations support:<br />
<br />
&bull; Using a compiler command-line option, such as -D to allow identifiers to be defined prior to<br />
translation;<br />
<br />
&bull; Using environment variables to achieve the same effect;<br />
<br />
&bull; Pre-defined identifiers provided by the compiler.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
If an attempt is made to use a macro identifier in a preprocessor directive, and that identifier has<br />
not been defined, then the preprocessor will assume that it has a value of zero. This may not meet<br />
developer expectations.<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_08</rule>
		<ruleTitle><![CDATA[The controlling expression of a #i f or #elif preprocessing directive shall evaluate to 0 or 1]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>


<span style="color:#B73232">Amplification</span><br>
<br />
This rule does not apply to controlling expressions in preprocessing directives which are not evaluated.<br />
Controlling expressions are not evaluated if they are within code that is being excluded and cannot<br />
have an effect on whether code is excluded or not.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Strong typing requires t he controlling expression of conditional inclusion preprocessing directives to<br />
have a Boolean value.<br />

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.4<br/>


]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Undecidable, System<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
A pointer should point to a const-qualified type unless either:<br />
<br />
&bull; It is used to modify an object, or<br />
<br />
&bull; It is copied to another pointer that points to a type that is not const-qualified by means of<br />
either:<br />
<br />
- Assignment, or<br />
<br />
- Memory move or copying functions.<br />
<br />
For the purposes of simplicity, this rule is written in terms of pointers and the types that they point to.<br />
However, it applies equally to arrays and the types of the elements that they contain. An array should<br />
have elements with const-qualified type unless either:<br />
<br />
&bull; Any element of the array is modified, or<br />
<br />
&bull; It is copied to a pointer that points to a type that is not const-qualifi ed by the means described<br />
above.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
This rule encourages best practice by ensuring that pointers are not inadvertently used to modify<br />
objects. Conceptually, it is equivalent to initially declaring:<br />
<br />
&bull; All arrays to have elements with const-qualified type, and<br />
<br />
&bull; All pointers to point to const-qualified types.<br />
<br />
and then removing const-qualification only where it is necessary to comply with the constraints of the<br />
language standard.<br />]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_14</rule>
		<ruleTitle><![CDATA[The restrict type qualifier shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
When used with care the restrict type qualifier may improve the efficiency of code generated by a<br />
compiler. It may also allow improved static analysis. However, to use the restrict type qualifier the<br />
programmer must be sure that the memory areas operated on by two or more pointers do not<br />
overlap.<br />
<br />
There is a significant risk that a compiler will generate code that does not behave as expected if restrict<br />
is used incorrectly.<br />
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_11</rule>
		<ruleTitle><![CDATA[When an array with external linkage is declared, its size should be explicitly specified]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to non-defining declarations only. It is possible to define an array and specify its size<br />
implicitly by means of initialization.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Although it is possible to declare an array with incomplete type and access its elements, it is safer<br />
to do so when the size of the array may be explicitly determined. Providing size information for each<br />
declaration permits them to be checked for consistency. It may also permit a static checker to perform<br />
some array bounds analysis without needing to analyse more than one translation unit.<br />
<br />
]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_12</rule>
		<ruleTitle><![CDATA[Within a n enumerator list, the value of an implicitly-specified enumeration constant shall be unique]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
An implicitly-specified enumeration constant has a value 1 greater than its predecessor. If the first<br />
enumeration constant is implicitly-specified then its value is 0.<br />
<br />
An explicitly-specified enumeration constant has the value of the associated constant expression.<br />
If implicitly-specified and explicitly-specified constants are mixed within an enumeration list, it is<br />
possible for values to be replicated. Such replication may be unintentional and may give rise to<br />
unexpected behaviour.<br />
<br />
This rule requires that any replication of enumeration constants be made explicit, thus making the<br />
intent clear.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_08_10</rule>
		<ruleTitle><![CDATA[An inline function shall be declared with the static storage class]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
If an inline function is declared with external linkage but not defined in the same translation unit, the<br />
behaviour is undefined.<br />
<br />
A call to an inline function declared with external linkage may call the external definition of the function,<br />
or it may use the inline definition. Although this should not affect the behaviour of the called function,<br />
it might affect execution timing and therefore have an impact on a real-time program.<br />
<br />
Note: an inline function can be made available to several translation units by placing its definition in a<br />
header file.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 5.9<br>
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_12</rule>
		<ruleTitle><![CDATA[A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
A macro parameter that is used as an operand of a # or ## operator is not expanded prior to being<br />
used. The same parameter appearing elsewhere in the replacement text is expanded. If the macro<br />
parameter is itself subject to macro replacement, its use in mixed contexts within a macro replacement<br />
may not meet developer expectations.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_11</rule>
		<ruleTitle><![CDATA[A macro parameter immediately following a # operator shall not immediately be followed by a ## operator]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
The order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor<br />
operators is unspecified. The use of # and ## is discouraged by Rule 20.10. In particular, the result of<br />
a # operator is a string literal and it is extremely unlikely that pasting this to any other preprocessing<br />
token will result in a valid token.<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.10<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_10</rule>
		<ruleTitle><![CDATA[The # and ## preprocessor operators should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Rationale</span><br>
<br />
The order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor<br />
operators is unspecified. In some cases it is therefore not possible to predict the result of macro<br />
expansion.<br />
<br />
The use of the ## operator can result in code that is obscure.<br />
<br />
Note: Rule 1.3 covers the undefined behaviour that arises if either:<br />
<br />
&bull; The result of a # operator is not a valid string literal; or<br />
<br />
&bull; The result of a ## operator is not a valid preprocessing token.

<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.11<br/>]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_14</rule>
		<ruleTitle><![CDATA[All #else, #elif and #endif preprocessor directives shall reside in the same file a s the #if, #ifdef or #ifndef directive to which they are related]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br>
<br />
directives which are spread over multiple files. Requiring that a #if directive be terminated within the<br />
same file reduces the visual complexity of the code and the chance that errors will be made during<br />
maintenance.<br />
<br />
Note: #if directives may be used within included fi les provided they are terminated within the same<br />
file.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_20_13</rule>
		<ruleTitle><![CDATA[A line whose first token is # shall be a valid preprocessing directive]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
White-space is permitted between the # and preprocessing tokens.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
A preprocessor directive may be used to conditionally exclude source code until a corresponding<br />
#else, #elif or #endif directive is encountered. A malformed or invalid preprocessing directive contained<br />
within the excluded source code may not be detected by the compiler, possibly leading to the exclusion<br />
of more code than was intended.<br />
<br />
Requiring all preprocessor directives to be syntactically valid, even when they occur within an excluded<br />
block of code, ensures that this cannot happen.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_07</rule>
		<ruleTitle><![CDATA[If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
The rationale is described in the introduction on composite operators and expressions (see Section 8.10.3).<br />
Restricting implicit conversions on composite expressions means that sequences of arithmetic<br />
operations within an expression must be conducted in exactly the same essential type. This reduces<br />
possible developer confusion.<br />
<br />
Note: this does not imply that all operands in an expression are of the same essential type.<br />
The expression u32a + u16b + u16c is compliant as both additions will notionally be performed in<br />
type uint32_t. In this case only non-composite expressions are implicitly converted.<br />
<br />
The expression (u16a + u16b) + u32c is non-compliant as the left addition is notionally performed<br />
in type uint16_t and the right in type uint32_t, requiring an implicit conversion of the composite<br />
expression u16a + u16b to uint32_t.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.6, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_08</rule>
		<ruleTitle><![CDATA[The value of a composite expression shall not be cast to a different essential type category or a wider essential type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Rationale</span><br/>
<br />
The rationale is described in the introduction on composite operators and expressions (see Section 8.1 0.3).<br />
Casting to a wider type is not permitted as the result may vary between implementations. Consider<br />
the following:<br />
<br />
( uint32_t ) ( u16a + u16b );<br />
<br />
On a 16-bit machine the addition will be performed in 16 bits with the result wrapping modulo-2<br />
before it is cast to 32 bits. However, on a 32-bit machine the addition will take place in 32 bits and<br />
would preserve high-order bits that would have been lost on a 16-bit machine.<br />
<br />
Casting to a narrower type with the same essential type category is acceptable as the explicit truncation<br />
of the result always leads to the same loss of information.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.5, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br><br>
The following table is used in the definition of this rule.<br/><br/>

<center>
<table align="center" border="1" cellpadding="6">
<tr align="left">
<td rowspan="1">Description</td><td rowspan="1">Operator or Operand</td><td rowspan="1">Precedence</td>
</tr>

<tr align="left">
<td>Primary </td><td>identifier, constant, string literal, (expression)</td><td>16(high)</td>
</tr>

<tr align="left">
<td>Postfix</td><td>[] () (function call) , -> ++(post-increment) --(post-decrement) () {} (C99: compound literal)</td><td>14</td>
</tr>

<tr align="left">
<td>Unary</td><td>++(pre-increment) --(pre-decrement) & * + - ~ ! sizeof defined (preprocessor)</td><td>14</td>
</tr>

<tr align="left">
<td>Cast</td><td>()</td><td>13</td>
</tr>

<tr align="left">
<td>Multiplicative</td><td>* / %</td><td>12</td>
</tr>

<tr align="left">
<td>Additive</td><td>+ -</td><td>11</td>
</tr>

<tr align="left">
<td>Bitwise shift</td><td><< >></td><td>10</td>
</tr>

<tr align="left">
<td>Relational</td><td>< > <= >=</td><td>9</td>
</tr>

<tr align="left">
<td>Equality</td><td>== !=</td><td>8</td>
</tr>

<tr align="left">
<td>Bitwise And</td><td>&</td><td>7</td>
</tr>

<tr align="left">
<td>Bitwise XOR</td><td>^</td><td>6</td>
</tr>

<tr align="left">
<td>Bitwise OR</td><td>|</td><td>5</td>
</tr>

<tr align="left">
<td>Logical AND</td><td>&&</td><td>4</td>
</tr>

<tr align="left">
<td>Logical OR</td><td>||</td><td>3</td>
</tr>

<tr align="left">
<td>Conditional</td><td>?:</td><td>2</td>
</tr>

<tr align="left">
<td>Assignment</td><td>= *= /= %= += -= <<= >>= &= ^= !=</td><td>1</td>
</tr>

<tr align="left">
<td>Comma</td><td>,</td><td>0(low)</td>
</tr>

</table>
</center>
<p>
<br/><br/>
The precedences used in this table are chosen to allow a concise description of the rule. They are<br />
not necessarily the same as those that might be encountered in other descriptions of operator<br />
precedence.<br />
<br />
For the purposes of this rule, the precedence of an expression is the precedence of the element<br />
(operand or operator) at the root of the parse tree for that expression.<br />
<br />
For example: the parse tree for the expression a << b + c can be represented as:<br /><br />

<span style="font-family:Arial">
&nbsp;<<<br/>
&nbsp;/&nbsp;&nbsp;\<br/>
a&nbsp;&nbsp;&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;c<br/>
</span>
<br/><br/>

The element at the root of this parse tree is '<<' so the expression has precedence 10.<br/><br/>

The following advice is given:<br />
<br />
&bull; The operand of the sizeof operator should be enclosed in parentheses;<br />
<br />
&bull; An expression whose precedence is in the range 2 to 12 should have parentheses around any<br />
operand that has both:<br />
<br />
- Precedence of less than 13, and<br />
<br />
- Precedence greater than the precedence of the expression.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The C language has a relatively large number of operators and their relative precedences are not<br />
intuitive. This can lead less experienced programmers to make mistakes. Using parentheses to<br />
make operator precedence explicit removes the possibility that the programmer&rsquo;s expectations are<br />
incorrect. It also makes the original programmer&rsquo;s intention clear to reviewers or maintainers of the<br />
code.<br />
<br />
It is recognized that overuse of parentheses can clutter the code and reduce its readability. This rule<br />
aims to achieve a compromise between code that is hard to understand because it contains either<br />
too many or too few parentheses.<br />]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_05</rule>
		<ruleTitle><![CDATA[The value of an expression should not be cast to an inappropriate essential type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
The casts which should be avoided are shown in the following table, where values are cast (explicitly<br />
converted) to the essential type category of the first column.
<br/><br/>
<center>
<table border="1" cellpadding="3" cellspacing="0">
			<tbody>
				<tr align="center">
					<td>
						Essential type category</td>
					<td colspan="6" style="background:#E2DFB7">
						&nbsp;from</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						to</td>
					<td style="background:#E2DFB7">
						Boolean</td>
					<td style="background:#E2DFB7">
						character</td>
					<td style="background:#E2DFB7">
						enum</td>
					<td style="background:#E2DFB7">
						signed</td>
					<td style="background:#E2DFB7">
						unsigned</td>
					<td style="background:#E2DFB7">
						floating</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						Boolean</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						character</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						enum</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid*</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						signed</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						unsigned</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
				<tr align="center">
					<td style="background:#E2DFB7">
						floating</td>
					<td>
						avoid</td>
					<td>
						avoid</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
					<td>
						&nbsp;</td>
				</tr>
			</tbody>
		</table>
</center>
<br/>
<p>
* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same<br />
essential enumerated type. Such casts are redundant.<br />
<br />
Casting from void to any other type is not permitted as it results in undefined behaviour. This is<br />
covered by Rule 1.3.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
An explicit cast may be introduced for legitimate functional reasons, for example:<br />
<br />
&bull; To change the type in which a subsequent arithmetic operation is performed;<br />
<br />
&bull; To truncate a value deliberately;<br />
<br />
&bull; To make a type conversion explicit in the interests of clarity.<br />
<br />
However, some explicit casts are considered inappropriate:<br />
<br />
&bull; In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the<br />
case when casting to another type which is defined as essentially Boolean;<br />
<br />
&bull; A cast to an essentially enum type may result in a value that does not lie within the set of<br />
enumeration constants for that type;<br />
<br />
&bull; A cast from essentially Boolean to any other type is unlikely to be meaningful;<br />
<br />
&bull; Converting between floating and character types is not meaningful as there is no precise<br />
mapping between the two representations.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is<br />
defined as essentially Boolean. This allows the implementation of non-C99 Boolean models.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.8<br>
</p>

]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_02</rule>
		<ruleTitle><![CDATA[The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>
<br />
If the right hand operand is negative, or greater than or equal to the width of the left hand operand,<br />
then the behaviour is undefined.<br />
<br />
If, for example, the left hand operand of a left-shift or right-shift is a 16-bit integer, then it is important<br />
to ensure that this is shifted only by a number in the range 0 to 15.<br />
<br />
See Section 8.10 for a description of essential type and the limitations on the essential types for the<br />
operands of shift operators.<br />
<br />
There are various ways of ensuring this rule is followed. The simplest is for the right hand operand to<br />
be a constant (whose value can then be statically checked). Use of an unsigned integer type will ensure that the operand is non-negative, so then only the upper limit needs to be checked (dynamically at<br />
run time or by review). Otherwise both limits will need to be checked]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_06</rule>
		<ruleTitle><![CDATA[The value of a composite expression shall not be assigned to an object with wider essential type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/><br/>
This rule covers the assigning operations described in Rule 10.3.<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>
The rationale is described in the introduction on composite operators and expressions (see Section 8.10.3).

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7, Section 8.10.3<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_03</rule>
		<ruleTitle><![CDATA[The comma operato r should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>

Use of the comma operator is generally detrimental to the readability of code, and the same effect
can usually be achieved by other means.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_03</rule>
		<ruleTitle><![CDATA[The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
The following operations are cove red by this rule:<br />
<br />
1. Assignment as defined in the Glossary;<br />
<br />
2. The conversion of the constant expression in a switch statement&rsquo;s case label to the promoted<br />
type of the controlling expression.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
The C language allows the programmer considerable freedom and will permit assignments between<br />
different arithmetic types to be performed automatically. However, the use of these implicit conversions<br />
can lead to unintended results, with the potential for loss of value, sign or precision. Further details of<br />
concerns with the C type system can be found in Appendix C.<br />
<br />
The use of stronger typing, as enforced by the MISRA essential type model, reduces the likelihood of<br />
these problems occurring.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
1. A non-negative integer constant expression of essentially signed type may be assigned to an object<br />
of essentially unsigned type if its value can be represented in that type.<br />
<br />
2. The initializer { 0 } may be used to initialize an aggregate or union type.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.4, Rule 10.5, Rule 10.6<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_12_04</rule>
		<ruleTitle><![CDATA[Evaluation of constant expressions should not lead to unsigned integer wrap-around]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Advisory</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to expressions that satisfy the constraints for a constant expression, whether or not<br />
they appear in a context that requires a constant expression.<br />
<br />
If an expression is not evaluated, for example because it appears in the right operand of a logical AND<br />
operator whose left operand is always false, then this rule does not apply.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Unsigned integer expressions do not strictly overflow, but instead wrap-around. Although there may<br />
be good reasons to use modulo arithmetic at run-time, it is less likely for its use to be intentional at<br />
compile-time.<br />
]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
This rule applies to operators that are described in usual arithmetic conversions (see C90 Section 6.2.1.5,<br />
C99 Section 6.3.1.8). This includes all the binary operators, excluding the shift, logical &amp;&amp;, logical ||<br />
and comma operators. In addition, the second and third operands of the ternary operator are covered<br />
by this rule.<br />
<br />
Note: the increment and decrement operators are not covered by this rule.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
The C language allows the programmer considerable freedom and will permit conversions between<br />
different arithmetic types to be performed automatically. However, the use of these implicit conversions<br />
can lead to unintended results, with the potential for loss of value, sign or precision. Further details of<br />
concerns with the C type system can be found in Appendix C.<br />
<br />
The use of stronger typing, as enforced by the MISRA essential type model, allows implicit conversions<br />
to be restricted to those that should then produce the answer expected by the developer.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
The following are permitted to allow a common form of character manipulation to be used:<br />
<br />
1. The binary + and += operators may have one operand with essentially character type and the<br />
other operand with an essentially signed or essentially unsigned type;<br />
<br />
2. The binary - and -= operators may have a left-hand operand with essentially character type<br />
and a right-hand operand with an essentially signed or essentially unsigned type.
<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.3, Rule 10.7<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_01</rule>
		<ruleTitle><![CDATA[Operands shall not be of an inappropriate essential type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>


<span style="color:#B73232">Amplification</span><br/>
<br />
In the following table a number within a cell indicates where a restriction applies to the use of an<br />
essential type as an operand to an operator. These numbers correspond to paragraphs in the Rationale<br />
section below and indicate why each restriction is imposed.<br /><br />

<center>
<table align="center" border="1" cellpadding="6">
<tr align="center" >
<td rowspan="2">Operator</td><td rowspan="2">Operand</td><td colspan="6">Essential type category of arithmentic operand</td>
</tr>

<tr align="center" >
<td>Boolean</td><td>character</td><td>enum</td><td>signed</td><td>unsigned</td><td>floating</td>
</tr>

<tr align="center">
<td>[ ] </td><td>integer</td><td>3</td><td>4</td><td></td><td></td><td></td><td>1</td>
</tr>

<tr align="center">
<td>+ (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td></td><td></td>
</tr>

<tr align="center">
<td>- (unary)</td><td></td><td>3</td><td>4</td><td>5</td><td></td><td>8</td><td></td>
</tr>

<tr align="center">
<td>+ -</td><td>either</td>
<td>3</td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>* /</td><td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>%</td>
<td>either</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td></td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>< > <= >=</td><td>either</td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>== !=</td><td>either</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr align="center">
<td>! && ||</td><td>any</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td><< >></td><td>left</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td><< >></td><td>right</td>
<td>3</td>
<td>4</td>
<td>7</td>
<td>7</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>~ & | ^</td><td>any</td>
<td>3</td>
<td>4</td>
<td>5,6</td>
<td>6</td>
<td></td>
<td>1</td>
</tr>

<tr align="center">
<td>?:</td><td>1st</td>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>

<tr align="center">
<td>?:</td><td>2nd and 3rd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>


</table>
</center>
<br/>
<p>
Under this rule the ++ and -- operators behave the same way as the binary + and - operators.<br />
Other rules place further restrictions on the combination of essential types that may be used within<br />
an expression.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
1. The use of an expression of essentially fl oating type for these operands is a constraint violation.<br />
<br />
2. An expression of essentially Boolean type should always be used where an operand is<br />
interpreted as a Boolean value.<br />
<br />
3. An operand of essentially Boolean type should not be used where an operand is interpreted<br />
as a numeric value.<br />
<br />
4. An operand of essentially character type should not be used where an operand is interpreted<br />
as a numeric value. The numeric values of character data are implementation-defined.<br />
<br />
5. An operand of essentially enum type should not be used in an arithmetic operation because<br />
an enum object uses an implementation-defi ned integer type. An operation involving an<br />
enum object may therefore yield a result with an unexpected type. Note that an enumeration<br />
constant from an anonymous enum has essentially signed type.<br />
<br />
6. Shift and bitwise operations should only be performed on operands of essentially unsigned<br />
type. The numeric value resulting from their use on essentially signed types is implementationdefi<br />
ned.<br />
<br />
7. The right hand operand of a shift operator should be of essentially unsigned type to ensure that<br />
undefined behaviour does not result from a negative shift.<br />
<br />
8. An operand of essentially unsigned type should not be used as the operand to the unary minus<br />
operator, as the signedness of the result is determined by the implemented size of int.<br />
<br />
<span style="color:#B73232">Exception</span><br/>
<br />
A non-negative integer constant expression of essentially signed type may be used as the right hand<br />
operand to a shift operator.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.2<br>
</p>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_10_02</rule>
		<ruleTitle><![CDATA[Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br>
<span style="color:#B73232">Applies to</span> &nbsp;&nbsp;C90, C99<br><br>

<span style="color:#B73232">Amplification</span><br/>
<br />
The appropriate uses are:<br />
<br />
1. For the + operator, one operand shall have essentially character type and the other shall have<br />
essentially signed type or essentially unsigned type. The result of the operation has essentially<br />
character type.<br />
<br />
2. For the - operator, the first operand shall have essentially character type and the second<br />
shall have essentially signed type, essentially unsigned type or essentially character type. If both<br />
operands have essentially character type then the result has the standard type (usually int in this<br />
case) else the result has essentially character type.<br />
<br />
<span style="color:#B73232">Rationale</span><br/>
<br />
Expressions with essentially character type (character data) shall not be used arithmetically as the data<br />
does not represent numeric values.<br />
<br />
The uses above are permitted as they allow potentially reasonable manipulation of character data.<br />
For example:<br />
<br />
&bull; Subtraction of two operands with essentially character type might be used to convert between<br />
digits in the range &lsquo;0&rsquo; to &lsquo;9&rsquo; and the corresponding ordinal value;<br />
<br />
&bull; Addition of an essentially character type and an essentially unsigned type might be used to<br />
convert an ordinal value to the corresponding digit in the range &lsquo;0&rsquo; to &lsquo;9&rsquo;;<br />
<br />
&bull; Subtraction of an essentially unsigned type from an essentially character type might be used to<br />
convert a character from lowercase to uppercase.

<br/><br/><span style="color:#B73232">See also</span>&nbsp;Rule 10.1<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_10</rule>
		<ruleTitle><![CDATA[The Standard Library time and date functions shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
None of the facilities that are specified as being provided by &lt;time.h&gt; shall be used.<br />
<br />
In C99, the identifier wcsftime shall not be used and no macro with this name shall be expanded.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The time and date functions have unspecified, undefined and implementation-defined behaviours<br />
associated with them.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_11</rule>
		<ruleTitle><![CDATA[The standard header file &lt;tgmath.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
None of the facilities that are specified as being provided by &lt;tgmath.h&gt; shall be used.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Using the facilities of &lt;tgmath.h&gt may result in undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_12</rule>
		<ruleTitle><![CDATA[The exception handling features of &lt;fenv.h&gt; should not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Advisory<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
The identifiers feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag and fetestexcept shall not be<br />
used and no macro with one of these names shall be expanded.<br />
<br />
The macros FE_INEXACT, FE_DIVBYZERO, FE_UNDERFLOW, FE_OVERFLOW, FE_INVALID and FE_ALL_EXCEPT,<br />
along with any implementation-defined floating-point exception macros, shall not be used.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
In some circumstances, the values of the floating-point status f ags are unspecified and attempts to<br />
access them may lead to undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Minor</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_09</rule>
		<ruleTitle><![CDATA[The library functions bsearch and qsort of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
The identifiers bsearch and qsort shall not be used and no macro with one of these names shall be<br />
expanded.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
If the comparison function does not behave consistently when comparing elements, or it modifies any<br />
of the elements, the behaviour is undefined.<br />
<br />
Note: the unspecified behaviour, which relates to the treatment of elements that compare as equal,<br />
can be avoided by ensuring that the comparison function never returns 0. When two elements are<br />
otherwise equal, the comparison function could return a value that indicates their relative order in<br />
the initial array.<br />
<br />
The implementation of qsort is likely to be recursive and will therefore place unknown demands on<br />
stack resource. This is of concern in embedded systems as the stack is likely to be a fixed, often small,<br />
size.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_07</rule>
		<ruleTitle><![CDATA[The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br><br>

The identifiers atof, atoi, atol and, for C99 only atoll, shall not be used and no macro with one of these
names shall be expanded.

<br><br>
<span style="color:#B73232">Rationale</span><br><br>
These functions have undefined behaviour associated with them when the string cannot be converted.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br><br>

The identifiers abort, exit, getenv and system shall not be used and no macro with one of these names
shall be expanded.

<br><br>
<span style="color:#B73232">Rationale</span><br><br>
These functions have undefined and implementation-defined behaviours associated with them.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_05</rule>
		<ruleTitle><![CDATA[The standard header file &lt;signal.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br><br>
None of the facilities that are specified as being provided by &lt;signal.h&gt; shall be used.<br><br>
<span style="color:#B73232">Rationale</span><br><br>
Signal handling contains implementation-defined and undefined behaviour.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br><br>

This rule applies to the functions that are specified as being provided by &lt;stdio.h&gt; and, in C99,<br>
their wide-character equivalents specified in Sections 7.24.2 and 7.24.3 of the C99 Standard as being<br>
provided by &lt;wchar.h&gt;.<br><br>
None of these identifi ers shall be used and no macro with one of these names shall be expanded.<br>


<br>
<span style="color:#B73232">Rationale</span><br><br>
Streams and file I/O have unspecified, undefined and implementation-defined behaviours associated
with them.
<br><br>
<span style="color:#B73232">See also</span>&nbsp;Rule 22.1, Rule 22.3, Rule 22.4, Rule 22.5, Rule 22.6<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
The identifiers calloc, malloc, realloc and free shall not be used and no macro with one of these names<br />
shall be expanded.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Use of dynamic memory allocation and deallocation routines provided by The Standard Library can<br />
lead to undefined behaviour, for example:<br />
<br />
&bull; Memory that was not dynamically allocated is subsequently freed;<br />
<br />
&bull; A pointer to freed memory is used in any way;<br />
<br />
&bull; Accessing allocated memory before storing a value into it.<br />
<br />
Note: this rule is a specific instance of Dir 4.12.


<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Dir 4.12, Rule 18.7, Rule 22.1, Rule 22.2<br/>
]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_04</rule>
		<ruleTitle><![CDATA[The standard header file &lt;setjmp.h&gt; shall not be used]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br><br>
None of the facilities that are specified as being provided by &lt;setjmp.h&gt; shall be used.<br><br>
<span style="color:#B73232">Rationale</span><br><br>
<b>setjmp</b> and <b>longjmp</b> allow the normal function call mechanisms to be bypassed. Their use may lead to<br>
undefined and unspecified behaviour.<br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_01</rule>
		<ruleTitle><![CDATA[#define and #undef shall not be used on a reserved identifier or reserved macro name]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to the following:<br />
<br />
&bull; Identifiers or macro names beginning with an underscore;<br />
<br />
&bull; Identifiers in file scope described in Section 7, &ldquo;Library&rdquo;, of The Standard;<br />
<br />
&bull; Macro names described in Section 7, &ldquo;Library&rdquo;, of The Standard as being defined in a standard<br />
header.<br />
<br />
This rule also prohibits the use of #define or #undef on the identifier defined as this results in explicitly undefined behaviour.<br />
<br />
This rule does not include those identifi ers or macro names that are described in the section of the<br />
applicable C standard entitled &ldquo;Future Library Directions&rdquo;.<br />
<br />
The Standard states that defining a macro with the same name as:<br />
<br />
&bull; A macro defined in a standard header, or<br />
<br />
&bull; An identifier with file scope declared in a standard header<br />
<br />
is well-defined provided that the header is not included. This rule does not permit such definitions on<br />
the grounds that they are likely to cause confusion.<br />
<br />
Note: the macro NDEBUG is not defined in a standard header and may therefore be #define&rsquo;d.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Reserved identifiers and reserved macro names are intended for use by the implementation.<br />
Removing or changing the meaning of a reserved macro may result in undefined behaviour.


<br/><br/>

<span style="color:#B73232">See also</span>&nbsp;Rule 20.4<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_21_02</rule>
		<ruleTitle><![CDATA[A reserved identifier or macro name shall not be declared]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Amplification</span><br>
<br />
See the Amplification for Rule 21.1 for a description of the relevant identifiers and macro names.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The implementation is permitted to rely on reserved identifiers behaving as described in The Standard<br />
and may treat them specially. If reserved identifiers are reused, the program may exhibit undefined<br />
behaviour.]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_01</rule>
		<ruleTitle><![CDATA[A loop counter shall not have essentially floating type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Rationale</span><br>
<br />
When using a floating-point loop counter, accumulation of rounding errors may result in a mismatch<br />
between the expected and actual number of iterations. This can happen when a loop step that is not<br />
a power of the floating-point radix is rounded to a value that can be represented.<br />
<br />
Even if a loop with a floating-point loop counter appears to behave correctly on one implementation,<br />
it may give a different number of iterations on another implementation.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2</br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
The three clauses of a for statement are the:<br />
<br />
First clause which<br />
<br />
&bull; Shall be empty, or<br />
<br />
&bull; Shall assign a value to the loop counter, or<br />
<br />
&bull; Shall define and initialize the loop counter (C99).<br />
<br />
Second clause which<br />
<br />
&bull; Shall be an expression that has no persistent side effects, and<br />
<br />
&bull; Shall use the loop counter and optionally loop control flags, and<br />
<br />
&bull; Shall not use any other object that is modified in the for loop body.<br />
<br />
Third clause which<br />
<br />
&bull; Shall be an expression whose only persistent side effect is to modify the value of the loop<br />
counter, and<br />
<br />
&bull; Shall not use objects that are modified in the for loop body.<br />
<br />
There shall only be one loop counter in a for loop, which shall not be modified in the for loop body.<br />
<br />
A loop control flag is defined as a single identifier denoting an object with essentially Boolean type that<br />
is used in the Second clause.<br />
<br />
The behaviour of a for loop body includes the behaviour of any functions called within that statement.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
The for statement provides a general-purpose looping facility. Using a restricted form of loop makes<br />
code easier to review and to analyse.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
All three clauses m ay be empty, for example for ( ; ; ), so as to allow for infinite loops.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.1, Rule 14.3, Rule 14.4</br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_03</rule>
		<ruleTitle><![CDATA[Controlling expressions shall not be invariant]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Undecidable, System</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
This rule applies to:<br />
<br />
&bull; Controlling expressions of if, while, for, do &#8230; while and switch statements;<br />
<br />
&bull; The first operand of the ?: operator.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
If a controlling expression has an invariant value, it i s possible that there is a programming error. Any<br />
code that cannot be reached due to the presence of an invariant expression may be removed by the<br />
compiler. This might have the effect of removing defensive code, for instance, from the executable.<br />
<br />
<span style="color:#B73232">Exception</span><br>
<br />
1. Invariants that are used to create infinite loops are permitted.<br />
<br />
2. A do &#8230; while loop with an essentially Boolean controlling expression that evaluates to 0 is<br />
permitted.<br />

<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 2.1, Rule 14.2</br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_14_04</rule>
		<ruleTitle><![CDATA[The controlling expression of an if statement and the controlling expression of an iteration- statement shall have essentially Boolean type]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;&nbsp;&nbsp;Required</br>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;&nbsp;&nbsp;Decidable, Single Translation Unit</br>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99</br></br>

<span style="color:#B73232">Amplification</span><br>
<br />
The controlling expression of a for statement is optional. The rule does not re quire the expression to<br />
be present but does require it to have essentially Boolean type if it is present.<br />
<br />
<span style="color:#B73232">Rationale</span><br>
<br />
Strong typing requires the controlling expression of an if statement or iteration-statement to have<br />
essentially Boolean type.
<br/><br/>
<span style="color:#B73232">See also</span>&nbsp;Rule 14.2, Rule 20.8</br>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_03_02</rule>
		<ruleTitle><![CDATA[Line-splicing shall not be used in // comments]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C99<br/><br/>


<span style="color:#B73232">Amplification</span><br/><br/>

Line-splicing occurs when the \ character is immediately followed by a new-line character. If the<br/>
source file contains multibyte characters, they are converted to the source character set before any<br/>
splicing occurs.<br/><br/>

<span style="color:#B73232">Rationale</span><br/><br/>

If the source line containing a // comment ends with a \ character in the source character set, the<br/>
next line becomes part of the comment. This may result in unintentional removal of code.<br/>
Note: line-splicing is described in Section 5.1.1.2(2) of both C90 and C99.<br/><br/>

<span style="color:#B73232">See also</span> &nbsp;Dir 4.4<br/>

]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[MISRA_C_2012]]></ruleSetName>
		<ruleSetDesc><![CDATA[Guidelines for the use of the C language in critical systems]]></ruleSetDesc>
		<rule>MISRA_C_2012_03_01</rule>
		<ruleTitle><![CDATA[The character sequences /* and // shall not be used within acomment]]></ruleTitle>
		<ruleDesc><![CDATA[<span style="color:#B73232">Category</span> &nbsp;Required<br/>
<span style="color:#B73232">Analysis</span> &nbsp;&nbsp;Decidable, Single Translation Unit<br/>
<span style="color:#B73232">Applies to</span> &nbsp;C90, C99<br/><br/>
<span style="color:#B73232">Rationale</span><br/><br/>

If a comment starting sequence, /* or //, occurs within a /* comment, is it quite likely to be caused<br/>
by a missing */ comment ending sequence.<br/>
If a comment starting sequence occurs within a // comment, it is probably because a region of code<br/>
has been commented-out using //.<br/><br/>

<span style="color:#B73232">Exception</span><br/><br/>

The sequence // is permitted within a // comment.<br/>]]></ruleDesc>
		<ruleSeverity>Major</ruleSeverity>
		<ruleType><![CDATA[Others]]></ruleType>
	</ruleInfo>
	<bug>
		<violationHash>947308152540492206318406726177459660661</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>101</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1311219781043396655314672062588455388704</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>136960617994610387251351816308464117736</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>58897346201700354835082347698078376805</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[A compatible declaration shall be visible when an object or function with external linkage is defined]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Function miro_way_completionS doesn't have prototype before definition ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>118864163710166190496375519737352203898</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170424248334534562195879407892209696849</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>35</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument tail has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1831646356213850427913974230416315376285</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103549443199917589553544368545671305646</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>49</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>160850858682113201366938399748323477145</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14301928324890265785615485820315586589</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>86</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument head has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1312740530012264302012258007534800747360</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>10749758720919537610077404835679872868</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>970785626189891990448726043562164216</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>94</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>130089406180130439944240586772997054162</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>73</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>101734439932848484672282431262949747585</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>162540282549550796526694975083219706394</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>412543037436062648417635958356356086530</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>36</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Even though the parameter of function Q_make is not existed, a void type parameter has not been declared explicitly.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>155895030541459666779141126893188626552</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument after has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>185912510909815294816467957101728046025</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter now has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>125576515939224575441282400521491619102</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>81929680515541894312040577258232172526</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function fputs is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14667517671302278924737357507095636719</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74638589315444798237794700494379273287</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6331511372639948515746840615679232583</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>133</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1731392834457051231315020628491300946910</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>52518561269387378753924249040192946600</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>171780420800478797424585269739429295594</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>96</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>164197359343188560965968539699232358079</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3635718965027792593158771770985746621</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>21</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument tail has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>146893480112819634954096275917313791317</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1614862023706711196016182089039442930199</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>802789644668495376613017289486930559630</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter tail has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>21586691259679984702225658915277924202</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[Functions and objects should not be defined with external linkage if they are referenced in only one translation unit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[File scope function which used only at a file miro_return is not declared as static ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1095339133131999532412470373845602228054</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>37</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument node has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1449772798257633587016700423693157231200</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1040213086556964983017348315989418872445</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function fputs is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>97382616198934640725285646295073894065</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>99377310552145633396531689377165553988</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135807005885825864841289028401922654050</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_08_07</rule>
		<ruleTitle><![CDATA[Functions and objects should not be defined with external linkage if they are referenced in only one translation unit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[File scope function which used only at a file miro_check is not declared as static ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>77399932981152677849935261281189305035</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>24</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter tail has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103980228004901199746444265179281755442</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function system is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1242012622584805890615124867488243888380</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>40438516438335055337076577729315889433</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>307547151685416826317291931625337662280</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function free is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>100525726335180104892079627633785806059</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17577341527910530489325095605829182750</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>54</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>254898545748336877510320941181082096132</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>327314462118656058216680658256671429187</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>61</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1145007433678548981717362568997108836091</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>749705990729863159417764339757990601237</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134013041944355031177639594747260147856</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function system is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>249596690456022357913294196212622331973</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>112744330092743667214587665460234529942</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1414680439329816934313039383223254647301</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>721650956346586299112781033158662729614</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>183828092909048893065284183820886522845</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17520328459416222944943144518934561790</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>118478469009582138936807110287745123722</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74621078842220381566794765596568067573</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>581238403206683040617621277131174012432</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>145365944149947622036423371767385328585</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>113931689121522182267122224326007266521</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_08_04</rule>
		<ruleTitle><![CDATA[A compatible declaration shall be visible when an object or function with external linkage is defined]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Function miro_return doesn't have prototype before definition ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>123430641107521264428524323785328560497</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>96</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>75618879527848592877757563810833098921</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>46559440365699920457373140160333796524</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>39757878014950765065997545823519159777</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>72</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30183679885344673649517097306026551904</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>89</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument save has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135154344187164025909750821330779924862</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>97</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2345354857028876766829399954057153345</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>513036863897098779317493712246748851677</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>179346160338861200895020961211776235048</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>61949415380336051445118402861385233088</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1825865179262774151611329199244527163965</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>379976848695616721016494608641431351411</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>123485365941174760115616344823858914422</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>41</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>447349039077368544915163351049132935239</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>3</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Even though the parameter of function Q_make is not existed, a void type parameter has not been declared explicitly.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103453723157290706611121444608015672286</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>126896271220403351471232521600602988682</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17939527786144079408839569809718683511</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>671872251666521584310899274168113885823</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>8724051412067572710834277202378848678</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>25</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>457903953765022763517242085171689757469</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>129</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>986037055226035519116926770092284753334</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>22103616282212229087692061840135724354</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>66463014228627402008687208716342865541</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>135</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1425282541807267758816580542021530734192</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>103</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function free is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1070376539843724157314869620255355035909</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>120958831289357598027517570204422230017</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>40889846374979510971069565717275153480</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>25</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9223167388768851206448506239662325276</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>92949977310480273227429012694328285726</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>141523041186931853488906722634982637562</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>80</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>86388909464931483826629582420616122213</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[num expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>127867179695569755561509846092714054064</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>568000086922121654215676833200274399010</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>278361470456885059612685609530098797400</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>26908758028150438112591563183839792116</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>139</line>
		<rule>MISRA_C_2012_03_01</rule>
		<ruleTitle><![CDATA[The character sequences /* and // shall not be used within acomment]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[String // used in comment.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>59148846906506163134466560388995778427</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_21_08</rule>
		<ruleTitle><![CDATA[The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function system is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>84195302105644038472544866115489301179</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17154134937613497367329565640311467157</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>36290415467187401479295597010674731965</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>42435713034715044695436179549665889534</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1577146330290137985915159346199303626327</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>68</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>106135392515757207311299986720777501751</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_09_03</rule>
		<ruleTitle><![CDATA[Arrays shall not be partially initialized]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The array miro_map has been initialized partially.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>194653713185138015417245018917547130163</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>88923855556017647059775946718076149594</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>901000821385990993314805831914072203148</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>74</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>605228503998754240514936424697214438573</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>137</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>634692838768601537714885525226307000031</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[function should have a single point of exit at the end]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function map_re_find  has exit points 2 times ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1820560520809667580814769504133912696140</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>12</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function fputs is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1262837619587882694017603208672674256658</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>160</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68063833260440180505503451142529198457</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument node has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>53005657046341971542084113256209941208</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[next expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>81028157608512552268659193247149343838</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>157282650418877421706598484805646424158</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>123</line>
		<rule>MISRA_C_2012_15_04</rule>
		<ruleTitle><![CDATA[There should be no more than one break or goto statement used to terminate any iteration statement]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[Only one jump statement should be used in loop statement, but it is used 9 times. ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18282466258037000456867533374207488527</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>234</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>28926563650471109627664967014347868852</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator - should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>824628749943661724914029801721449226042</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>213</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>7011365312150613481072005818001656839</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>4</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Even though the parameter of function main is not existed, a void type parameter has not been declared explicitly.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>34617980445976485794612046449476676409</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>178</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>533880155292791908216654004551776387600</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>23</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument node has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>383475522602553998512359276513941114427</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>63</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function system is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68159863498614315811166083614153489155</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>13452078585975778715169852752845749956</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>49784804422604595473730544776108649619</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>90</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103179922006915389286240427061477362465</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>59224577063970336118811825695785448083</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>276152569641314138412984287614937978764</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>144625477270325708335482938971674651577</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>181</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>58067071180158500053543055621931503009</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>65</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument head has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17202719428766211126533620660033449782</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>57</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1368328609188607123911420931967165237451</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1618673180207532345171645325941062104</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter x has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>148520483318596645429102348709263165809</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>43116695570168217515319353852893152002</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>88</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument remove has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>623417696151693942215654664010941415357</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.h</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>1</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed file stdio.h is included ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>89856641752462077181849372274080425482</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>93946271562118148001718338254490428819</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>157</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68127215445814546395317043292165468289</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>45</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument tail has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>156593917025233623878612266814832142060</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>93</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>168546950068869743614017840216771018324</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter y has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>62236664023391518473215816204579542657</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>80160203554773735718277043591589097776</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>72677065610361946848344641187838019994</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>87</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1173415313127782948216857256783754065966</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>17</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function fputs is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>417206500074413511716307861376939177765</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68217471982393982432544508704167782978</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9380477539639293074642491829380343873</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<line>83</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter after has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14953578203267222377693651098179826270</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>138</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1833308863985669674714670469473814966298</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>3</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Even though the parameter of function Q_make is not existed, a void type parameter has not been declared explicitly.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>121156122772643734645250570842013495653</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>121</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1484401120659973748012438924474375934009</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_08_03</rule>
		<ruleTitle><![CDATA[All declarations of an object or function shall use the same names and type qualifiers]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Identifier used in the declaration move is not identical to which used in the definition moving  ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>501357062191076724517844428825137194502</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>126</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>147700227726013420653277065928847668115</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>370143107696568783213097330732561695818</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>208</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1182085814846671706214624234177918927583</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>69</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[num expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>53566427633500538173270435859144007019</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>114</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function free is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>275027498995029155410840013046790487899</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator <= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>57035770690529517738330996410058090149</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>48</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument tail has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>160948705915436704513134596255107709972</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>54</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument node has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>755890374241391213810277823030553957950</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>8</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function malloc is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>438630638150965279310320304102996670396</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>70</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1433017608715245768011220172896505934775</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>136</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>217379110870328693514112024411857742427</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>39</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>769508488912847276713048205504403211428</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>30</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function malloc is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>114273460701732068641945550203767789708</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>196</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9117387938433555666513498636713429031</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>131</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>617985525421938760018086465769981254932</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>644388351124522248710773441235290583624</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>88</line>
		<rule>MISRA_C_2012_21_02</rule>
		<ruleTitle><![CDATA[A reserved identifier or macro name shall not be declared]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Prohibit defining/declaring the specific variable]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>141280385814808830133257370108412503003</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>4</line>
		<rule>MISRA_C_2012_08_02</rule>
		<ruleTitle><![CDATA[Function types shall be in prototype form with named parameters]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Even though the parameter of function main is not existed, a void type parameter has not been declared explicitly.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>893799727508627795415261258356576907983</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>27</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1166899942483973289614853522447753278658</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1780378632139923705815245524105949988425</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>134</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function free is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>99489401303266576337198112278170152510</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<line>7</line>
		<rule>MISRA_C_2012_21_03</rule>
		<ruleTitle><![CDATA[The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function malloc is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>22970404750137713872746304486638377129</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>139</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>105022895740432665317787353030254821080</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>164</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>154289530510009462944773007356547262689</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<line>127</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter head has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>250893452586000393511249566271270666592</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18872422265157497397637564447535889520</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>81</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function getchar is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1088334193235243159810939370285784987903</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>91</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>121073339175547981301396430769916077988</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>443810322391889932315055277215150224184</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>141</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1158788147154297077915029674171703324594</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>193</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>57926561873450450783991342079690104547</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1420299448988966188016949999446314946105</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<line>11</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>16286294105894726736980332456917282727</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>52</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1229458858303283729812751273163943547669</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_15_05</rule>
		<ruleTitle><![CDATA[function should have a single point of exit at the end]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function miro_check  has exit points 3 times ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>26424378004778065797957815769386568149</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>185</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>74710094407887085982004482669883740247</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>142</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator >= should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135550097526810561471569764376723929500</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>174</line>
		<rule>MISRA_C_2012_13_04</rule>
		<ruleTitle><![CDATA[The result of an assignment operator should not be used]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The result of assign operator should not be used.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>608601029559878952210771587152669665826</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>218</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1085266781020073706916072678206492693859</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>140</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>136533980625563703524959994757865717434</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>130</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>943991589004693100213635228977201671354</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>44</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1597651470161383503615812626513307595465</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>65</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17404948132830414932455995604421326283</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>188</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1365251183678909148012413843519126306226</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>15</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>152619992472633858246772395586432568560</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<line>67</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument node has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>257590955103039768515656673788880914570</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>171</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14560943134029737756909826863702244034</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>127</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>902286361775837366815148702172100091659</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>200</line>
		<rule>MISRA_C_2012_21_06</rule>
		<ruleTitle><![CDATA[The Standard Library input/output functions shall not be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Not allowed function printf is used ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>13878447762080937352962691789836308008</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>43</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>91396098613418445871509877311994793706</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>203</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>162916699238903556011765416479379447730</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>99</line>
		<rule>MISRA_C_2012_15_06</rule>
		<ruleTitle><![CDATA[The body of an iteration-statement or a selection-statement shall be a compound-statement]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The then or else clause of if statement is not a compound statement ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>394016872181746599016756975209269769487</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>132</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator == should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>178328446805346048878139512295693261960</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<line>8</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function fputs is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>101572855701946776659516541026257654359</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>110</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[check expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>107400289496055070244693424231938159134</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>5636485703249941378124474268287760904</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<line>39</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>8426332976992316211286495633769715684</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_11_09</rule>
		<ruleTitle><![CDATA[The macro NULL shall be the only permitted form of integer null pointer constant]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[A null pointer constant has not been used as a macro NULL or (void*)0.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>13060491820893931791314109226223661934</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>150649449555289575327745550637305697322</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<line>50</line>
		<rule>MISRA_C_2012_17_08</rule>
		<ruleTitle><![CDATA[A function parameter should not be modified]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The function parameter addr_check has been changed.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>97427991323920217165769103929558978719</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>128</line>
		<rule>MISRA_C_2012_18_04</rule>
		<ruleTitle><![CDATA[The +, -, += and -= operators should not be applied to an expression of pointer type]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator + has been used in the pointer-type expression.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>123200873317691715285297573327766314519</violationHash>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<line>47</line>
		<rule>MISRA_C_2012_17_07</rule>
		<ruleTitle><![CDATA[The value returned by a function having non-void return type shall be used]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Result of function printf is neither used nor saved ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1265995009710291346518154524689172154081</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>105</line>
		<rule>MISRA_C_2012_08_13</rule>
		<ruleTitle><![CDATA[A pointer should point to a const-qualified type whenever possible]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The pointer-type variable or argument tail has not been changed within the function but the base type has not been declared as a const.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>970036554953436978311400164961257279512</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>166</line>
		<rule>MISRA_C_2012_12_01</rule>
		<ruleTitle><![CDATA[The precedence of operators within expression s should be made explicit]]></ruleTitle>
		<level>Minor</level>
		<content><![CDATA[The operator && should have parentheses.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>161723354958513276646121471607437450004</violationHash>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<line>106</line>
		<rule>MISRA_C_2012_10_04</rule>
		<ruleTitle><![CDATA[Both operands of an operator in which the usual arithmetic conversions are performeds hall have the same essential type category]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[Two operands of general arithmetic conversion are the different essential type. (char / signed)]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>86273605587391860414193239987718803428</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<line>152</line>
		<rule>MISRA_C_2012_13_05</rule>
		<ruleTitle><![CDATA[The right hand operand of a logical && or || operator shall not contain persistent side effects]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[The right-hand operand of a logical &&or || operator has side effect ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>656650859377890206012916879996776082354</violationHash>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<line>78</line>
		<rule>MISRA_C_2012_14_02</rule>
		<ruleTitle><![CDATA[A for loop shall be well-formed]]></ruleTitle>
		<level>Major</level>
		<content><![CDATA[prev expression in for statement is not used in initialization ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_return(struct link *, struct link *, char (*)*)]]></function>
		<functionStartLine>83</functionStartLine>
		<functionEndLine>101</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>10.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\Q_S.c</fileName>
		<function><![CDATA[main()]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>104</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>NaN</ncf>
		<ndf>12.0</ndf>
		<necl>28.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findS(struct link *, signed int)]]></function>
		<functionStartLine>65</functionStartLine>
		<functionEndLine>82</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_way_find(struct link *, char (*)*, signed int, signed int)]]></function>
		<functionStartLine>105</functionStartLine>
		<functionEndLine>235</functionEndLine>
		<cc>29.0</cc>
		<ncl>11.0</ncl>
		<nfp>4.0</nfp>
		<ncf>2.0</ncf>
		<ndf>7.0</ndf>
		<necl>91.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_short(struct link *)]]></function>
		<functionStartLine>86</functionStartLine>
		<functionEndLine>123</functionEndLine>
		<cc>8.0</cc>
		<ncl>4.0</ncl>
		<nfp>1.0</nfp>
		<ncf>2.0</ncf>
		<ndf>2.0</ndf>
		<necl>22.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[find_state(char (*)*, struct link *)]]></function>
		<functionStartLine>25</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>5.0</cc>
		<ncl>3.0</ncl>
		<nfp>2.0</nfp>
		<ncf>2.0</ncf>
		<ndf>1.0</ndf>
		<necl>12.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_remove(struct link *)]]></function>
		<functionStartLine>127</functionStartLine>
		<functionEndLine>138</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>5.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[miro_check(char (*)*, struct link *, signed int, signed int)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>79</functionEndLine>
		<cc>4.0</cc>
		<ncl>3.0</ncl>
		<nfp>4.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>14.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionQ(struct link *, char (*)*)]]></function>
		<functionStartLine>21</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>4.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_map_cpy(char (*)*, char (*)*)]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>17</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>5.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[map_re_find(struct link *)]]></function>
		<functionStartLine>48</functionStartLine>
		<functionEndLine>112</functionEndLine>
		<cc>5.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>9.0</ndf>
		<necl>29.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun2.c</fileName>
		<function><![CDATA[miro_way_completionS(struct link *, char (*)*)]]></function>
		<functionStartLine>35</functionStartLine>
		<functionEndLine>46</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>NaN</ncf>
		<ndf>0.0</ndf>
		<necl>3.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\miro_fun.c</fileName>
		<function><![CDATA[map_out(char (*)*)]]></function>
		<functionStartLine>4</functionStartLine>
		<functionEndLine>21</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>1.0</nfp>
		<ncf>4.0</ncf>
		<ndf>4.0</ndf>
		<necl>9.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make()]]></function>
		<functionStartLine>3</functionStartLine>
		<functionEndLine>20</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>3.0</ncf>
		<ndf>1.0</ndf>
		<necl>9.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_add(struct link *, signed int)]]></function>
		<functionStartLine>24</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>3.0</ncf>
		<ndf>1.0</ndf>
		<necl>10.0</necl>
	</metric>
	<metric>
		<fileName>C:\Temp\QA_source\miro\QS_fun.c</fileName>
		<function><![CDATA[Q_make_findQ(struct link *, signed int)]]></function>
		<functionStartLine>45</functionStartLine>
		<functionEndLine>60</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>7.0</necl>
	</metric>
</ci.CodeInspectorResult>
