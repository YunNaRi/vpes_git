<?xml version="1.0" encoding="UTF-8"?>
<ci.CodeInspectorResult>
	<summary>
		<prjName></prjName>
		<toolName>CodeScroll Code Inspector</toolName>
		<toolVersion>3.6</toolVersion>
		<numberOfCodeViolation>264</numberOfCodeViolation>
	</summary>
	<source>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<crc32>5418f3b7</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<crc32>decb2a82</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<crc32>a2bcaebe</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<crc32>e62cd4d7</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<crc32>a03d52f1</crc32>
		<isExcluded>false</isExcluded>
	</source>
	<source>
		<fileName>C:\Temp\poppad\RESOURCE.H</fileName>
		<crc32>1846e134</crc32>
		<isExcluded>true</isExcluded>
	</source>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 객체나 함수가 현재 스코프 밖에서 보일 필요가 없다면 static으로 선언되어 외부로부터 가려져야 한다. 이렇게 하면 모듈화된 코드를 만들고 전역 네임스페이스가 복잡해지는 것을 제한할 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP32_C</rule>
		<ruleTitle><![CDATA[volatile을 제거하는 명시적 타입 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 포인터의 volatile qualification을 명시적으로 제거하는 타입 변환을 검사한다. volatile object가 non-volatile value의 사용에 의해 참조될 수 있으면 그 결과는 undefined behavior이다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 사용되지 않은 변수의 존재는 중요한 논리적 오류를 나타낼수 있다. 이러한 오류를 방지하기 위해, 사용되지 않은 변수들은 코드로부터 확인되고 제거되어야 한다. 
이 제안은 MSC12_C의 구체적인 케이스이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE32_C</rule>
		<ruleTitle><![CDATA[함수 매크로 사용시 인자 부분에 Preprocessor directive가 들어가면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로의 인자는 전처리 지시자를 포함하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR31_C</rule>
		<ruleTitle><![CDATA[문자열 관련 TR24731함수 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 데이터를 그 데이터 유지하기에 충분히 크지 못한 버퍼에 복사하는것은 버퍼 오버플로우를 발생한다. null-terminated 바이트 문자열(NTBS)은 제한되있지 않는 반면, 버퍼 오버플로우는 NTBS를 데이터를 조작할때 자주 일어난다. 이런 에러를 방지하기 위해 truncation을 통해서만 복사하거나, 또는 대상이 복사될 문자 데이터와 null-terminated 문자를 유지하기에 충분한 크기인지 확인하고 복사한다. (제안 STR03_C 참고) ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO44_C</rule>
		<ruleTitle><![CDATA[fsetpos()에 fgetpos()에서 반환된 값을 사용했는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ fsetpos 함수는 stream이 가리키는 스트림에서 pos로 표시되는 객체의 값에 따라 mbstate_t 객체와 파일 위치 표시자를 설정한다. 이때 pos는 같은 파일 스트림에 대해 fgetpos 함수를 호출해 성공적으로 반환된 값이어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM31_C</rule>
		<ruleTitle><![CDATA[중복 free 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 중복해서 메모리를 free하는것은 free된 후에 메모리에 계속해서 접근히는것과 유사하다. (MEM30_C 참조) 
먼저, 할당해제된 메모리에 대한 포인터를 읽는것은 undefined behavior이다. 포인터값이 애매하고 trap representation 을 가지기 때문이다. 후자의 경우 그렇게 하는것은  hardware trap을 일으킨다. free된 포인터를 읽는것이 trap을 일으키지 않을때, heap을 관리하는 자료구조가 프로그램에 보안 취약점을 전파할수 있는 방식으로 깨질수 있다. 이런형태의 이슈는 double-free 취약점으로 지칭된다. 실제  double-free 취약점은 엉뚱한 코드를 실행하도록 활용될수 있다. 
double-free 취약점을 제거하기 위해, 동적으로 할당된 메모리가 정확히 한번만 해제되도록 보장할 필요가 있다. 프로그래머는 반복이나 조건문에서 메모리를 free할때 주의해야한다. 코드가 잘못되면, 이런 구조는 double-free 취약점으로 유도될수 있다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP11_C</rule>
		<ruleTitle><![CDATA[integer type과 floating type 간 명시적 타입 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ incompatible type 사이의 타입 변환을 금지한다. integer type과 floating type 간의 명시적인 타입 변환은 기대하는 값과 다른 엉뚱한 값을 발생시킬 우려가 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP02_C</rule>
		<ruleTitle><![CDATA[floating point 수식은 equality 검사에서 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 컴퓨터는 유한한 개수의 숫자를 표현할 수 있다. 따라서 반복되는 이진 표기값을 정확하게 표현하는 것은 이진 부동소수점을 가진 대부분의 부동 소수점 표현으로는 불가능하다. 즉, 부동 소수점 연산에서는 정확하지 않은 결과가 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP04_C</rule>
		<ruleTitle><![CDATA[scanf의 float type 입력값에 대해 isinf, isnan 수행 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ Floating-point 숫자는 infinity 와 NaN (not-a-number) 라는 2종류의 예외적값을 가질수 있다. 이 값들은 예외 또는 풀수없는 floating point 연산의 결과로서 반환된다. (FLP32_C 참고) 추가적으로, 그들은 사용자에 의해 scanf 혹은 유사한 함수로 직접 입력될수 있다. 그런 값들을 탐지하거나 다루는데 실패하는것은 undefined behavior를 일으킬수 있다. 
NaN 값은 특히 문제가 된다. 식 NaN==NaN (모든 가능한 NaN값에 대해) 이 false 를 반환하기 때문이다. 인자중 하나로서 NaN과 이루어진 어떤 비교는 false 를 반환한다. 그리고 NaN 상의 모든 계산 함수들은 그것들을 코드로 전파한다. 즉, 코드의 어떤 장소에 NaN 이 들어갔고, 적절히 다루어지지 않는다면, 멀리 떨어진 다른 장소에서 문제를 일으킬수 있다. 
scanf 와 같은 Formatted-input 함수들은 INF, INFINITY, NAN 값들을 %f 포맷에 대한 올바른 입력값으로 받아들일것이고, 악의적인 사용자에게 그것들을 프로그램에 직접 입력시키는것을 허용한다. 프로그램은 모든 floating point 입력값들이 이런 값들을 가지고 있지 않은지, 가지고 있다면(특히 그것들이 사용자에 의해 제외된다면) 부적절한지를 확실히 검사해야 한다. <math.h> 라이브러리는 이것을 위한 두가지 매크로를 가지고 있다: isinf, isnan ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT05_C</rule>
		<ruleTitle><![CDATA[scanf, fscanf 사용 제한 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 문자를 입력받고 그들을 integer로 변환하는 함수가 모든 가능한 입력에 대한 에러를 다룰수 없다면 그 함수들을 사용하지 말아야한다. 예를들면, 문자열 데이터를 stdin 또는 (fscanf()와 vscanf() 의 경우) 다른 입력 stream 으로부터 읽는데 사용될수 있는 scanf(), fscanf(), vscanf(), vfscanf() 와 같은 formatted input 함수들. 이 함수들은 올바른 integer값에 대해서는 잘 동작하지만 잘못된 값에 대해서는 강인한 에러처리가 부족하다. 
대안으로,  null-terminated 바이트 문자열로 문자 데이터를 입력받고 integer 값으로 변환하는데 strtol() 또는 관련된 함수를 사용한다. (제안 INT06_C 참고) ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT34_C</rule>
		<ruleTitle><![CDATA[범위를 벗어난 값으로 shift 연산자를 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 비트 시프트에서 피연산자가 정수 타입인 경우 정수 승계가 일어나며, 왼쪽 피연산자의 승계된 타입이 결과값의 타입이 된다. 만일 오른쪽 피연산자의 값이 음수이거나 승계된 왼쪽 피연산자의 값과 같거나 큰 경우 정의되지 않은 동작이 일어난다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR32_C</rule>
		<ruleTitle><![CDATA[가변길이배열의 인덱스가 유효한지 검사]]></ruleTitle>
		<ruleDesc><![CDATA[ Variable-length arrays (VLA) 는 그들이 integer 상수 식이 아닌 크기로 선언되고 block 스코프 또는 함수 prototype 스코프에서만 선언될수 있고 linkage를 가지지 않는 점을 제외하고 본질적으로 전통적인 C 배열과 같다. variable-length array 는 integer 식의 크기와 vla의 선언이 둘다 실행시간에 평가되는 곳에서 선언될수 있다. variable-length array 에 제공되는 크기 argument가 양의 integer 값이 아니면 undefined behavior 이다(C99의 Annex J 의 undefined behavior 69 참고). 더해서, argument의 크기가 과도하면 프로그램이 예측하지 못한방식으로 동작할수 있다. 공격자는 치명적인 프로그램 데이타를 덮어씀으로서 이 동작을 유발시킬수 있다[Griffiths 2006]. 프로그래머는 반드시 variable-length arrays로의 크기 argument 가 올바른지 예외적 integer 조건의 결과로 인해 깨져있지는 않은지 확인해야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR10_C</rule>
		<ruleTitle><![CDATA[기본타입과 L타입의 문자열 결합 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ MISRA 2008에 의하면, wide string literal 과 narrow string literal 의 결합은 undefined behavior를 유도한다. 이것은 C99 ISO/IEC 9899:1999 에 의하면 묵시적인  undefined behavior 이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 아래 식에서, index가 0보다 작을때 return 문장에서 증가 식의 동작은 undefined 43 이다. 어떤 구현체에서 증가는 하드웨어 trap을 작동시킬수 있다. 또 다른 구현체에서 증가는 역참조되었을때 하드웨어 trap을 작동시키는 결과를 만들어낼수 있다. 또 다른 구현체는 테이블로부터 동떨어진 object를 가리키는 포인터를 역참조하는 포인터를 만들어낼수도 있다. object에 접근하는 이러한 포인터를 사용하는것은 정보를 노출하거나 잘못된 object 변경되는 경우를 일으키도록 유도할수 있다. 

int* f(int index) { 
... 
static int table[TABLESIZE]; 
... 
return table + index; 
}  ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>POS44_C</rule>
		<ruleTitle><![CDATA[스레드를 종료시키는 시그널 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 스레드를 종료시키는 잡을 수 없는 시그널을 사용하는 것은 비단 해당 시그널 뿐만 아니라 프로세스 전체를 종료시킬 수 있기 때문에 사용하지 말아야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO33_C</rule>
		<ruleTitle><![CDATA[입출력 함수의 반환값이 검증되지 않아 변수가 초기화되지 않은 상태로 사용되는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 입출력 함수가 정상적으로 수행되지 않은 경우, 반환값을 받는 변수가 초기화 되지 않은 상태로 남아있을 수 있다. 그 변수를 사용하는 경우에 발생할 수 있는 undefined behavior를 피하기 위해 함수 수행 실패에 대한 검증이 있어야 한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR33_C</rule>
		<ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 많은 함수는 유효한 값을 반환하기도 하고 -1이나 null 포인터와 같은 오류 값을 반환하기도 한다. 함수의 성공적인 수행을 확인하기 위하여 반환값을 검사해야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 정수 오버플로는 undefined behavior를 유발한다. 따라서 signed 정수에서의 연산이 signed 오버플로를 발생시키지 않도록 보장해야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT07_C</rule>
		<ruleTitle><![CDATA[숫자 값의 용도로 사용되는 char에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 세 개의 타입 char, signed char, unsigned char를 통틀어 문자 타입이라고 한다. 컴파일러는 그것이 signed char이든 unsigned char이든 간에 char가 같은 범위, 표현, 동작을 갖도록 정의한다. 하지만 어느 것을 고르든 char는 나머지 두 개의 타입과는 분리된 타입이고 서로 호환되지 않는다. 숫자 값이나 저장공간으로 쓸 때는 항상 signed char나 unsigned char를 사용하라. 이렇게 하는 것이 문자 타입의 부호와 상관없이 호환 가능한 코드를 만드는 유일한 방법이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT30_C</rule>
		<ruleTitle><![CDATA[unsigned integer 타입의 상수에 대한 wrap around가 일어나면 안됨 ]]></ruleTitle>
		<ruleDesc><![CDATA[ unsigned 정수 연산은 결과 값이 정수 표현 범위를 벗어나는 경우 래핑될 수 있다. 이러한 래핑이 발생하면 버퍼 오버플로를 초래하거나 공격자로 하여금 임의 코드를 수행하게 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>API00_C</rule>
		<ruleTitle><![CDATA[FILE 타입을 파라미터로 가지는 함수에서 파라미터에 대한 검증이 존재하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C와 C++커뮤니티에서 방어적인 프로그래밍의 일부로 거론 되어지는 함수 호출자와 피호출자에서 일어나는 중복되는 검증의 큰 문제는 퍼포먼스에 있다. 어느 한쪽에서만 검증이 이루어지는 체계가 필요하다. 호출자에서 검증이 이루어지면 잘못된 값이 인자로 전달되는 자체를 막아주기 때문에 효율적이다. 피호출자에서 검증이 이루어지면 코드가 한 부분에 캡슐화되어 코드의 양이 줄고 일관적인 검증이 가능해진다. 안전과 보안상의 이유로 이 표준에서는 피호출자에서 파라미터를 검증하는 것을 추천한다.  ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC35_C</rule>
		<ruleTitle><![CDATA[switch문에서 첫번째 case 레이블 이전에 어떤 실행문도 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ switch 문장 안에서 첫번째  case 레이블 앞에는 어떤 실행문도을 포함하지 말라. 그런 문장들은 컴파일러가 무시하기 때문에 결코 실행되지 않는다. 
만약 프로그래머가 변수를 선언하고 그것들을 첫번째 cast문장의 앞에서 초기화 하고 어떤 case문장들 안에서 그 변수들을 사용하려는 시도들 한다면 그 변수들은 switch 블록 scope 안의 scope를 가질것이지만 초기화되지는 않을것이며 따라서 쓰레기값을 가지게 될것이다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP09_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 할당 크기를 입력하는 인자에 sizeof를 포함한 expression을 사용했는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 타입의 사이즈를 하드코딩 하면 안된다. 기본 타입의 사이즈는 컴파일러에 따라 혹은 같은 컴파일러 사이에도 버전에 따라 달라질 수 있기 때문이다. 따라서 sizeof 연산자의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR07_C</rule>
		<ruleTitle><![CDATA[문자열 관련 TR24731함수 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ ISO/IEC TR 24731 은 C 표준 함수들을 대체하도록 디자인된 다음버젼의 함수들을 정의한다. 예를들어 ISO/IEC TR 24731 Part I 은 strcpy(), strcat(), strncpy(),  strncat() 를 대체하는  strcpy_s(), strcat_s(), strncpy_s(), strncat_s() 를 정의한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE30_C</rule>
		<ruleTitle><![CDATA[여러 문자열을 붙여서 유니버설 문자열 이름을 만드는 매크로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99는 identifier들, 문자 상수들, 기본 문자집합에 없는 문자들로 된 string literal들에 쓰일수 있는 universal character name을 지원한다. universal character name \Unnnnnnnn 는 그것의 8자리의 identifier 가 nnnnnnnn 인 문자들을 지시한다. 유사하게, universal character name \unnnn 는 그것의 4자리의 identifier 가 nnnn 인 문자들을 지시한다. 그리고 그것의 8자리의 identifier는 0000nnnn이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC37_C</rule>
		<ruleTitle><![CDATA[non-void return type의 함수에서 명시적 return이 존재하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 반환 타입이 void가 아닌 함수에서 마지막 brace가 끝나기 전에 return문이 존재하지 않았다면 해당 함수의 반환 값은 정의되어 있지 않다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC33_C</rule>
		<ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ asctime 함수는 struct tm *timeptr을 인자로 받아서 sprintf로 조합시킨 최대 길이 26(마지막 널 캐릭터 포함)의 string을 반환한다. 만약 인자로 전달된 timeptr의 값에 문제가 있다면 sprintf에서 오버플로가 발생하게 된다. 따라서 asctime 함수에 전달되는 인자는 검증되어야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 우선 순위가 다른 연산자 혼용 시 괄호를 사용할 것을 권장한다. 연산자의 우선 순위를 완벽히 이해하지 못 한 채로 혼용하는 경우 의도와 다른 결과를 초래할 수 있기 때문이다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO39_C</rule>
		<ruleTitle><![CDATA[파일 입출력 사이에 플러시나 파일 위치 조정 함수가 존재하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 파일 스트림에 대해서 입력 다음에 fflush 호출이나 파일 위치 조정 함수(fseek, fsetpos, rewind)의 호출 없이 바로 출력을 수행하면 안되며, 반대로 출력 다음에 파일 위치 조정 함수 없이 바로(입력에서 파일 끝에 도달하지 않은 이상) 입력을 수행하면 안된다. 구현에 따라서 텍스트 파일을 업데이트 모드로 여는 것(혹은 생성하는 것)이 실제로는 바이너리 스트림을 열 수도 있다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR07_C</rule>
		<ruleTitle><![CDATA[동일한 기능을 하는 함수라면 오류 검사를 제공하는 함수 사용을 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 동일한 기능을 수행하는 두 개의 함수 중 하나를 선택해야 한다면, 오류를 검사하고 보고해주는 함수를 사용할 것을 권장한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>SIG33_C</rule>
		<ruleTitle><![CDATA[raise() 함수 재귀적으로 호출 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99는 raise() 함수의 재귀적 호출을 불허한다. C99, Section 7.14.1.1#4[ISO/IEC 9899:1999] 에 따르면, 
abort 또는 raise 함수 호출의 결과로 signal이 발생하면, signal handler는 raise 함수를 호출해서는 안된다. 
(Annex J 의 undefined behavior 124 참조) ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL02_C</rule>
		<ruleTitle><![CDATA[identifier에 혼동 가능한 문자 사용 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 유사한 이름을 가지는 identifier 사이에서 혼동의 여지가 있는 문자의 사용을 검사한다. 혼란의 여지가 있는 문자들로는 여러가지가 있지만, 식별이 어려워 문제가 야기될 것이라 판단되는 0(zero)-O(capital o), 1(one)-l(lowercase L)-I(capital i)에 대해 검사한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>SIG31_C</rule>
		<ruleTitle><![CDATA[시그널 핸들러에서 변수 사용 제한 ]]></ruleTitle>
		<ruleDesc><![CDATA[ signal handler 에서 공유객체에 접근하거나 변경하는것은 일관성 없는 상태에 데이타를 남겨놓는 race condition을 일으킬수 있다. 이 규칙의 예외는 volatile sig_atomic_t 변수를 읽고 쓰는것이다. volatile 키워드의 필요성은 규칙 DCL34_C에 기술되어있다. 그것은 signal handler로부터 다른 어떤 타입의 객체에 접근하는 프로그램의 동작을 아는데 중요하다 (C99 의 Appendix J 의 undefined behavior 125 참고). 
sig_atomic_t 타입은 비동기적 interrupt 상황에서도 atomic entity로서 접근할수 있는 객체의 integer 타입이다. sig_atomic_t 타입은 구현체에 정의된다. SIG_ATOMIC_MIN 에서 SIG_ATOMIC_MAX 범위의 integer 값들은, 안전하게 해당 타입의 변수에 저장될수 있다. 추가적으로 sig_atomic_t 가 signed integer 타입일때, SIG_ATOMIC_MIN 는 -127보다 클수 없고 SIG_ATOMIC_MAX 는 127보다 작을수 없다. 그 외에는 SIG_ATOMIC_MIN 은 0이어야 하고 SIG_ATOMIC_MAX sms 255보다 작지 않다. SIG_ATOMIC_MIN 와 SIG_ATOMIC_MAX 매크로는 헤더 <stdint.h> 정의되어있다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL36_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언마다 type이 호환되는지(compatible) 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 다른 스코프에서 정의된 식별자나 한 스코프에서 여러 번 선언된 식별자는 링크 과정을 통해 같은 객체나 함수를 참조할 수 있다. 식별자는 외부 링크, 내부 링크, 링크 없음으로 분류된다. 외부 링크와 내부 링크를 모두 갖는 것으로 분류되는 식별자를 사용하면 정의되지 않은 행동을 초래할 수 있다. 컴파일 단위는 전처리 지시자 #include 로 포함되는 모든 소스와 헤더 파일과 소스 파일 자체를 포함한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 정수와 포인터를 서로 변환하는 일이 C에서 일반적이기는 하지만, 포인터에서 정수로, 정수에서 포인터로 변환하는 것은 구현마다 다르게 정의하고 있다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP18_C</rule>
		<ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 조건문이나 반목문의 조건절의 최상위 표현식에 대입연산자를 사용하면 안된다. 이는 대개 개발자의 실수이며 예상하지 못한 결과를 유발한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP13_C</rule>
		<ruleTitle><![CDATA[relational, equality 연산자가 결합되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 비교 또는 동등 연산자는 좌측부터 결합된다. 이 연산자들의 결합은 일반적인 결합과 다른 결과를 가진다. a &lt; b &lt; c 의 결과값은 해당 expression 자체의 참 거짓이 아니라, 만약 a가 b보다 큰 경우 1과 c를 비교하게 된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO07_C</rule>
		<ruleTitle><![CDATA[rewind() 보다 fseek() 사용 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ fseek()을 사용하는 것이 rewind()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 fseek()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM02_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ void * 타입의 object는 일반적인 data포인터이다. 그것은 어떤 object라도 가리킬수 있다. 어떤 incomplete 나 T 타입 object 에 대해, C는 T* 에서 void* 로, 또는 void* 에서 T* 로의 묵시적 변환을 허용한다. Standard C Library는 다른 타입의 object들에 대해 동작하도록 디자인된 함수의 파라메터와 return 타입을 선언하기 위해 void* 를 사용한다. 표준 메모리 할당함수 malloc(), calloc(), realloc() 의 경우가 그러하다. 
예를들면 c library 는 malloc()을 다음과 같이 선언한다. 

void *malloc(size_t); ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC31_C</rule>
		<ruleTitle><![CDATA[time_t, size_t 타입과 integer 타입간 비교 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수는 표준에서 반환 타입을 부분적으로 지정한 경우 동일한 타입의 리터럴 상수 값으로 비교돼야 한다. 부분적으로 지정된 타입이 unsigned char나 unsigned short로 구현된 경우 타입 값은 어떤 아키텍처에서 -1과 같은 정수 리터럴에 대해 같은 값을 갖고 있음에도 동일하다고 평가되지 않을 수 있다. C99에서 time_t 타입은 시간을 표현할 수 있는 산술 타입이 되도록 요구하고 있다. 시간을 표시하는 최선의 산술 타입을 결정하는 일은 구현에서의 몫이다. 만일 time_t가 signed int보다 작은 unsigned 정수 타입으로 구현됐다면, 항상 정수 리터럴 -1과 같지 않게 된다. 마찬가지로 size_t가 어떻게 구현됐는지에 따라 정수 리터럴 -1과 비교할 때 기대한 대로 평가되지 않을 수 있다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC38_C</rule>
		<ruleTitle><![CDATA[표준 라이브러리에 있는 매크로 이름은 재사용 되어선 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 표준 라이브러리에 있는 매크로를 재정의하면 안된다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC06_C</rule>
		<ruleTitle><![CDATA[메모리 초기화 관련 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 컴파일러가 프로그램 생성 시 사용되지 않거나 필요하지 않은 코드를 제거할 수 있다. 일반적으로 이런 방식은 이득이 되지만, 컴파일러가 필요 없다고 판단해 제거한 코드가 사실은 보안상의 이유로 추가된 것일 수 있다. 민감한 데이터를 저장하는데 사용한 버퍼를 지우기 위해 덮어쓰기를 수행하는 경우를 예로 들 수 있다. 따라서 민감한 데이터를 다룰 때는 의도한 대로 동작하는지 확인해봐야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>CON33_C</rule>
		<ruleTitle><![CDATA[라이브러리 함수 사용 시 발생할 수 있는 race condition을 방어하는 함수 사용 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strerror()는 사람이 읽을 수 있는 오류 내용을 반환한다. 하지만 이 오류 문자열은 다른 스레드에서 접근하고 수정이 가능하기 때문에 항상 일정하게 오류 문자열을 출력하는 것을 보장할 수 없다. 따라서 스레드 안정성을 보장하는 strerror_r()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP40_C</rule>
		<ruleTitle><![CDATA[const-qualified 타입의 변수가 수정되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ const-qualified 타입의 object를 non-const-qualified 타입의 lvalue를 사용하여 수정하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE10_C</rule>
		<ruleTitle><![CDATA[복수 구문 매크로를 do-while 루프로 묶었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로는 다수의 연속된 문장집합을 실행하는데 자주 사용된다. 
인라인 함수는, 일반적으로, 이런 일에 적합하다. (제안 PRE00_C를 참조). 그러나 때때로 그들은 실행가능하지 않다(매크로가 다른 타입들의 변수들에 대해 연산을 수행할때 등). 
매크로에서 다수의 문장이 사용될때, 그들은 do-while 루프 안에 함께 묶여있어야 한다. 그렇게 해서 매크로는 절 또는 단일 문장이 나타날것이 기대되는 위치 또는 문장 블록에 안전하게 나타날수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC04_C</rule>
		<ruleTitle><![CDATA[중첩된 C 스타일 주석 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 주석 내에서 /*를 사용하지 마라. 주석 마침 표시를 누락하면 에러가 발생할 소지가 많으며, 대부분 실수처럼 보이기 때문에 이런 식의 주석 사용은 권하지 않는다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC17_C</rule>
		<ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ switch문에서 case절에 break문이 없으면 fall through가 발생한다. 만약 의도적으로 break문을 생략한 것이 아니라면, 의도하지 않은 control flow가 발생하게 된다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 변수와 함수는 사용 가능한 최소 범위에서 선언되어야 한다. 더 큰 스코프에서 사용할 수 있도록 하는 것은 가독성이 떨어지고, 유지가 어려워진다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR05_C</rule>
		<ruleTitle><![CDATA[문자열 상수를 가리키는 포인터는 const로 선언되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ string literal들은 관념적으로 constant이고 결과적으로 const 한정자에 의해 보호되어야한다.  string literal들을 변형하려고 시도하지 않아야한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE07_C</rule>
		<ruleTitle><![CDATA[연속되는 물음표 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 물음표를 두 개 이상 연속해서 사용하는 경우 삼중자 표기로 오해할 수 있다.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 서로다른 타입에 대해 연산을 처리할 때에는 주의해야 한다. 정수 승계, 정수 변환 순위를 잘 이해하여 정수 변환 규칙에서 발생하는 변환들을 알고 있어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 코드의 가독성을 높이기 위하여 성공, 참/거짓, 동등 여부를 표현하는 것이 좋다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 모든 선언은 그 라인에 변수의 역할에 대한 설명 comment 가 있는 단일한 변수만을 위한 것이이어야 한다. 하나의 선언문에 다중 변수 선언은 변수들의 타입과 그들의 초기값에 관해서 혼란을 일으킬수 있다. 만약 하나이상의 변수가 하나의 선언문에 선언되면, 반드시 변수의 타입과 초기화 값에 주의해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>POS33_C</rule>
		<ruleTitle><![CDATA[vfork() 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ vfork() 함수는 많은 이식성과 보안상의 이슈를 가지고 있다. 모든 상황에서 vfork()보다 fork()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL08_C</rule>
		<ruleTitle><![CDATA[상수 정의에 상수간의 관계가 적절히 나타나게 정의되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 한 정의가 다른 정의에 영향을 미친다면 둘 간의 관계를 인코딩하고 각각을 따로 정의하지 마라.  ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE01_C</rule>
		<ruleTitle><![CDATA[함수 매크로의 파라미터가 괄호로 감싸졌는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로 정의는 모든 매개변수 이름에 괄호를 사용해야 한다.  ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO11_C</rule>
		<ruleTitle><![CDATA[함수 fopen 호출 시 지정된 mode 문자열을 사용해야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ C표준은 fopen() 함수 호출에 대해 mode로 사용할 수 있는 지정된 문자열을 식별한다. 표준을 따르고 호환 가능하게 하려면 반드시 지정된 문자열 중 하나를 써야 한다. (지정된 문자열 목록: r, w, a, rb, wb, ab, r+, w+, a+, r+b, rb+, w+b, wb+, a+b, ab+) ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>API04_C</rule>
		<ruleTitle><![CDATA[일관적으로 사용 가능한 오류 처리 메커니즘을 사용하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strlcpy()는 strcpy()보다 안전하고 일관적으로 설계되었으나 오류 처리에 대해서는 사용자가 직접 코드를 작성해야 한다. strcpy_m()은 오류 값을 반환하기 때문에 보다 일관적으로 구현이 가능하다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM05_C</rule>
		<ruleTitle><![CDATA[함수의 array type parameter에 사이즈 명시 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 과도한 스택할당을 피하라. 특히 스택의 확장이 제어될수 있는 상황이나 공격자에 의해 영향을 받을수 있는 상황에서. 
C99는  variable-length arrays (VLAs) 를 지원한다 [ISO/IEC 9899:1999]. 만약 배열 길이가 신뢰할수 없는 출처에 기인한다면 공격자는 스택에 과도한 할당을 수행하는 프로세스를 일으킬수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT13_C</rule>
		<ruleTitle><![CDATA[bitwise 연산자에 signed underlying type 피연산자 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 비트 연산자는 signed 정수에 대한 비트 연산이 구현마다 다르게 정의돼 있기 때문에 unsigned 정수 피연산자와만 사용돼야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP30_C</rule>
		<ruleTitle><![CDATA[평가순서에 따라 결과가 달라지는 문장사용금지 (sequence point detection) ]]></ruleTitle>
		<ruleDesc><![CDATA[ 표현식의 평가는 부수 효과를 가져오는데, 이 때 이전 평가 단계에서의 모든 부수 효과가 발생하고 다음 평가 단계에서의 부수 효과가 아무것도 발생하지 않은 지점에 해당하는 시퀀스 포인트라는 샐행 지점이 있다. C99의 6.5절에 따르면, 이전과 다음 시퀀스 포인트 사이의 객체는, 객체에 저장된 값을 표현식 평가로 한 번 수정할 수 있다. 또한 이전 값은 저장될 값을 결정하려는 목적으로만 읽을 수 있다. 이 요구사항은 전체 표현식의 모든 가능한 하위 표현식의 순서에 대해 만족돼야 한다. 그렇지 않다면 어떤 행동을 할지 예측할 수 없다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 배열의 원소를 참조하는 포인터에 대해서만 산술 연산을 수행해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR03_C</rule>
		<ruleTitle><![CDATA[string 관련 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 표준 함수인 strncpy()와 strncat()은 지정된 수 n개의 문자를 소스 문자열로부터 대상 배열로 복사한다. 소스 배열의 처음 n개의 문자 중에 널문자가 없다면 결과 값 역시 널문자로 종료되지 않고, n개를 초과하는 문자들은 버려진다. 따라서 널문자까지 복사될 만큼의 충분한 공간이 확보되었는지 주의를 기울여야 한다.  ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ENV31_C</rule>
		<ruleTitle><![CDATA[ setenv(), _putenv_s() 함수 호출 후 main() 함수의 세번 째 인자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 윈도우 _putenv_s() 함수를 호출했거나 환경변수를 수정하는 다른 값을 수정한 경우라면 envp 포인터는 더 이상 환경변수를 참조하고 있지 않을 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO34_C</rule>
		<ruleTitle><![CDATA[plain char/signed char 타입 사용 금지 상황 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 문자 입/출력 함수들  fgetc(), getc(), getchar() 는 모두 스트림으로 부터 문자를 읽고 int로 반환한다. 스트림이 end-of-file에 도달하면 end-of-file 지시자가 설정되고 함수는 EOF를 반환한다. 문자 입/출력 함수 fputc(), putc(), putchar(), ungetc() 또한 문자 또는 EOF를 반환한다. 
문자 입/출력 함수에 의해 반환되는 값은 그 값이  EOF 와 비교될것이라면 char 로 변환하지 말아야한다. 이들 함수의 반환값이 일단 char 타입으로 변환되면 문자값들이 EOF 와 구분할수 없게될수 있다. 또한  sizeof(int) == sizeof(char) 이면, 반환값을 capture 하기 위해 사용한 int 는 EOF 와 구분할수 없게될수 있다. sizeof(int) == sizeof(char) 에 대한 자세한 사항은 FIO35_C 를 참고. 올바른 문자 타입 사용에 대한 정보는 제안 STR00_C 를 참고. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR33_C</rule>
		<ruleTitle><![CDATA[memcpy 함수 사용시 배열에 복사 할 때 오버플로가 발생하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 데이터를 배열에 복사할 때 충분한 공간을 확보하지 않으면 오버플로가 발생한다.  ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP02_C</rule>
		<ruleTitle><![CDATA[논리연산자 && 과 || 의 오른쪽 피연산자에 side effect 포함금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 논리 AND와 논리 OR 연산자는 단축 평가를 수행한다. 즉 첫 번째 피연산자로 평가가 완료된 경우 두 번째 피연산자는 평가하지 않는다. 따라서 두 번째 연산자가 부수 효과를 갖고 있다면 이 부수 효과가 실제로 발생하는지 보이지 않으므로 주의해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP04_C</rule>
		<ruleTitle><![CDATA[함수 memcmp의 인자로 구조체 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 구조체는 메모리상으로 정렬시키기 위해 data가 pad된다. 이 pading의 내용이나 추가되는 패딩의 크기는 unspecified이다. 따라서 구조체 사이에 바이트단위의 비교가 시도된다면 그 결과가 부정확 할 수 있다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP37_C</rule>
		<ruleTitle><![CDATA[특정 함수의 특정 인자가 존재하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ POSIX 함수 open()은 세 번째 인자로 생성된 파일에 접근하는 모드를 결정하는 가변인자를 가진 함수다. 새로운 파일을 생성하기 위해 open()을 사용하고 세 번째 인자를 생략한다면, 파일은 의도하지 않은 접근 권한을 갖고 생성될 것이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP33_C</rule>
		<ruleTitle><![CDATA[변수 사용 전 값 할당 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 로컬의 자동 변수는 초기화되기 전에 사용될 경우 이상한 값이 들어 있다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP35_C</rule>
		<ruleTitle><![CDATA[함수의 반환 값을 인접한 다음 시퀀스 포인트에서 접근하거나 수정하지 마라 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수 호출의 결과 값을 다음 시퀀스 포인트 후에 접근 또느 수정하려고 한다면 정의되지 않은 결과를 얻게 된다. C함수는 배열을 반환할 수 없다. 하지만 배열을 가진 구조체나 공용체는 반환할 수 있다. 만약 함수 호출 후 얻은 반환 값에 배열이 있다면 그 배열은 표현식 내에서 접근되거나 수정되면 안된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR36_C</rule>
		<ruleTitle><![CDATA[string literal로 초기화된 문자 배열의 size를 지정하지 말것 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C standard는 배열 변수를 경계값으로 선하는것과 초기화 literal로 선언하는것 양쪽을 허용한다. 초기화 literal은 배열크기를 내포한다. 문자열에서 string literal에 의해 명세된 크기는 literal의 문자들의 수에 종료 null 문자 하나를 더한것이다.
string literal과 string literal의 문자들의 수에 부합하는 명시적인 경계값으로 선언된 배열변수에 의해 배열 변수가 초기화 되는것은 일반적이다. C99, Section 6.7.8, Initialization, paragraph 14.
그러나 string이 null-terminated byte string으로서 사용되도록 의도되면, 배열은 string을 유지하기에는 부족한 문자들을 가질것이다. 종료 null 문자는 수에 포함되지 않기 때문이다. 이러한 문자열은  null-terminated byte string으로 간주된다면 제한된 기능과 취약점을 유발할 가능성을 가진다. 
더 나은 접근방식은 string literal로 초기화 되는 string의 경계를 명세하지 않는것이다. 컴파일러가 자동적으로 종료 null 문자를 포함한 전체 string literal 를 위한 충분한 공간을 할당할것이기 때문이다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM34_C</rule>
		<ruleTitle><![CDATA[동적할당이 없는 포인터에 free 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 동적으로 할당되지 않은 메모리를 해제하는것은 규칙 MEM31_C 에서 논의된사항들과 유사한 심각한 에러를 유발할수 있다. 이 에러의 구체적인 결과는 구현체에 의존적이지만 그 범위는 아무것도 아닌것에서 프로그램 종료에까지 걸쳐있다. 구현체를 막론하고, 동적메모리 할당 함수(malloc() 같은것)에 의해 반환된 포인터가 아닌 다른 어떤것에는 free() 호출을 피해야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT15_C</rule>
		<ruleTitle><![CDATA[typedef 타입을 변환 포맷에 사용 시 오버플로 방지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 사용자가 지정한 타입들은 printf() 같은 포맷이 지정된 출력 함수나 scanf() 같은 포맷이 지정된 입력 함수와 사용하면 문제를 일으킨다. C99의 intmax_t와 uintmax_t 타입은 같은 부호를 갖는 정수 타입으로 표현될 수 있는 모든 값을 표현할 수 있다. 이로 인해 프로그래머가 정의한 정수 타입과 intmax_t, uintmax_t 간의 변환도 가능하다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR38_C</rule>
		<ruleTitle><![CDATA[특정 함수의 특정 인자에서 wide-char와 char혼용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strncpy, wcsncpy의 인자에서 wide-char과 char가 혼용되면 안된다. ASCII 문자 집합으로부터 wide char를 취하려고 하면 null 바이트가 포함될 수 있다.그 결과 정의되지 않은 행동이 유발된다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR34_C</rule>
		<ruleTitle><![CDATA[plain char type에 대한 묵시적 변환 제한 ]]></ruleTitle>
		<ruleDesc><![CDATA[ Signed character 는 더 큰 signed 타입으로 변환되거나 할당되기 전에 반드시 unsigned char 로 변환되어야 한다. 컴파일러가  signed char 또는 unsigned char 와 같은 range, representation, behavior를 가지는 char 를 정의하기 위한 범위를 가지기 전에, 이 룰은 signed char 와 (plain) char character 양쪽에 적용되어야 한다.
이 룰은 character data 가 음수로 해석될수 있는 값을 가질수 있는 케이스에만 적용할수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC21_C</rule>
		<ruleTitle><![CDATA[for의 조건에서 equality 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ for 또는 while 문장이 loop counter를 사용한다면, loop 종료를 위해서 inequality (연산자 !=) 연산자를 사용하기보다는 관계연산자(<등)를 사용하는것이 더 안전하다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL32_C</rule>
		<ruleTitle><![CDATA[External identifier가 식별 가능한지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ external identifier는 31번 째 문자까지 식별이 가능하다. 따라서 길이가 31이 넘는 external identifier에 대해서 31번째문자 까지가 다른 external identifier에 대해 유일하여 식별 가능한지 확인해야 한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL30_C</rule>
		<ruleTitle><![CDATA[automatic 객체의 주소는 그것이 더이상 존재하지 않게 된 후에도 남아있을수 있는 다른 객체에 할당되면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 객체는 프로그램 수행 시 자신에게 할당된 저장공간이 있는 부분에 존재한다. 객체가 상수 주소를 갖고 존재한다면 자신의 수명 내에서 마지막으로 저장된 값을 계속 유지하고 있을 것이다. 객체가 자신의 수명을 다한 후에도 참조된다면, 정의되지 않은 행동을 유발할 수 있다. 수명을 다한 객체를 참조하는 포인터 역시 정의되지 않은 값을 갖게 된다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC40_C</rule>
		<ruleTitle><![CDATA[내용이 없는 무한 루프를 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 루프 바디 내에서 아무것도 하지 않는 비어있는 무한루프는 좋은 해법이 아니며, 그것을 사용하는 코드는 없어야 한다. 그 해법은 그것이 아무것도 하지 않으면서도 CPU cycle을 소비하기 때문에 좋은 해법이 아니다. 최적화된 컴파일러는 그런 루프를 제거할수 있고, 그것은 예상치 못한 결과를 유도할수 있다. C1X 위원회 문서 [ISO/IEC 9899:201x] Section 6.8.5.6 에 의하면, volatile 객체들에 접근하지 않는 입/출력연산을 수행하지 않고, 바디,제어식 또는 (for 문장의 경우에서) 그것의 expression-3 안에서 동기화 또는 atomic 연산을 수행하지 않는 반복문장은, 구현체에 의해 종료로 가정될수 있다. 
이것은 컴파일러에게 그러한 빈 루프가 종료됨을 증명할수 없더라도 그것을  제거하는 식으로 변형시키는것을 허락하도록 의도된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO41_C</rule>
		<ruleTitle><![CDATA[특정 매크로 함수의 인자에 side-effect 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ side-effect를 가지는 stream 인자를 getc()나 putc()에 전달할 경우 예상하지 못한 결과가 발생할 수 있다. 따라서 해당 함수의 인자로 side-effect를 가지는 expression을 사용하지 말아야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ string literal은 컴파일 시점에 문자열과 null 종료문자를 포함한 static array로 생성된다. 만약 프로그램이 string literal를 수정하려고 하면 undefined behavior가 발생한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT33_C</rule>
		<ruleTitle><![CDATA[division by zero가 발생하면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ /, % 연산자의 두 번째 피연산자로 0(zero)가 오면 undefined behavior가 발생한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE11_C</rule>
		<ruleTitle><![CDATA[매크로 정의 시 semicolon으로 끝나는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로는 소스코드의 가독성을 높이기 위해 자주 사용된다. 매크로정의는 그것들이 하나의 또는 다수의 문장들로 확정되는지에 관계없이, 세미콜론으로 끝나서는 안된다. (제안 PRE10_C 참고) 필요하다면 세미콜론은 매크로 확장 안에 포함되어야한다. 의도치 않게 매크로 정의 끝에 세미콜론을 넣는것은 프로그램의 제어흐름을 변화시킬수 있다. 
이 문제를 피하는 다른 방식은 함수형 매크로 대신 inline이나 static함수를 사용하는것이다 (제안 PRE00_C 참고). 
일반적으로, 프로그래머는 매크로 정의의 끝에 세미콜론이 없음을 확인해야한다. 이러한 매크로를 사용하는 동안에 필요한곳에서 세미콜론을 가지게 하는것에 대한 책임은 매크로를 사용하는 사람에게 위임되어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM32_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 메모리 할당 함수의 반환 값은 할당의 성공이나 실패 여부를 의미한다. C99에 따르면 calloc(), malloc(), realloc()는 메모리 할당이 실패할 경우 null 포인터를 반환한다. 따라서 메모리 함수의 최종 상태를 확인한 뒤 문제가 발생한 경우에는 적절한 가이드를 해줘야 한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP34_C</rule>
		<ruleTitle><![CDATA[floating type의 expression의 값을 다른 type으로 묵시적 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 부동소수점 값이 더 작은 범위나 정밀도를 가진 부동소수점 값으로 변환되거나 정수로 변환되는 경우, 혹은 정수가 부동 소수점으로 변환되는 경우 값은 변환될 타입으로 표현 가능해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC14_C</rule>
		<ruleTitle><![CDATA[unsigned integer 타입에 ~ 연산자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ unsigned integer 타입의 정수에 보수 연산자(~)를 사용하는 것은 일반적으로 사용 가능하지만 표준으로 보장되지는 않는다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC12_C</rule>
		<ruleTitle><![CDATA[side effect 가 없고 제어흐름의 변화를 일으키지 않는 문장 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 실행되기는 하지만 아무 일도 발생하지 않거나 의도하지 않은 효과가 나타나는 경우는 대부분 코딩 에러로 인해서이며, 기대하지 않은 동작을 초래할 수 있다. 아무 효과도 없는 문장이나 표현식은 발견 후 제거해야 한다. 대부분 최근 컴파일러는 아무 효과도 발생하지 않는 코드에 대해 경고 메시지를 보내준다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[성능/자원]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>POS39_C</rule>
		<ruleTitle><![CDATA[시스템 간에 데이터를 전송할 때 정확한 byte ordering을 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 서로 다른 엔디언의 시스템 사이에 데이터를 전송할 때, 프로그래머는 시스템이 데이터를 풀이하기 전에 바이트 순서에 반전되는지에 대해 주의를 기울여야만 한다. htonl(), htons(), ntohl(), ntohs()는 network 바이트 순서와 host의 바이트 순서 간의 변환이 가능하도록 해주는 함수들이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수는 side effect를 가지는지 여부와 상관없이 유용한 값을 반환한다. 대부분의 경우 이 값은 함수가 성공적으로 수행되었는 또는 어떤 에러가 발생했는지 여부를 나타낸다. 혹은, 어떤 계산의 결과값을 가지기도 한다. 만약 반환 값이 있는 함수에 대해서는 그 의미있는 반환 값을 사용하는지 검사해야 한다. 만약 반환 값을 사용할 필요가 없는 함수라면 반환 타입을 void로 하도록 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP32_C</rule>
		<ruleTitle><![CDATA[수학함수가 안전하게 사용되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99 Section 7.12.1 은 math.h에 있는 수학함수들에 대한 두 타입의 error를 정의하고 있다.   [ISO/IEC 9899:1999]:domain error 는 입력인자가 정의된 함수의 domain을 초월했을때 error를 일으킨다.  range error 는 함수의 수학계산 결과가 명세된 타입의 object에 표현될수 없다면( extreme magnitude 로인한 경우 등) error를 일으킨다. Domain errors 는 함수 호출 전 bounds checking 으로 예방될수 있다. Range errors 는 거의 예방할수 없지만, range errors를 예방하는 대신 그것을 탐지하고 range error가 발생했을때의 사후처리를 해야한다 ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>API03_C</rule>
		<ruleTitle><![CDATA[표준 라이브러리에 있는 매크로,객체,함수들의 이름은 재사용 되어선 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 라이브러리 함수는 지속적으로 사용가능한 인터페이스가 되도록 유지되어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP06_C</rule>
		<ruleTitle><![CDATA[sizeof 연산자에 side effect expression 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ sizeof 연산자는 피연산자의 크기를 바이트 단위로 알려준다. 피연산자는 표현식일 수도 있고 괄호로 묶인 타입 이름일 수도 있다. 피연산자의 타입이 가변 배열 타입이 아닌 경우에는 평가되지 않는다. 부수 효과를 가져올 수 있는 표현식이 제공되는 경우에는 표현식이 평가되지 않았다는 사실을 모르는 프로그래머에게는 혼란을 줄 수 있다. 결국 프로그래머는 프로그램의 상태에 대해 유효하지 않은 가정을 하고, 이는 에러나 소프트웨어의 취약성으로 이어진다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP03_C</rule>
		<ruleTitle><![CDATA[floating 오류 처리 루틴 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ floating-point 연산중의 에러는 연산 전에 피연산자를 확인하는데 집중하는 프로그래머에 의해 자주 무시된다. floating-point 연산중에 발생하는 에러는 일반적으로 인정하는 바와 같이 결정과 진단이 어렵지만, 그렇게 함으로써 얻어지는 이점은 비용을 무릅쓸 만하다. 이 제안은 floating-point 연산중의 에러를 잡는 방향을 제시한다. 
floating-point 예외 조건이 일어났는지를 결정하는 가장 portable한 방식은 C99에 의해 제공되는 fenv.h 의 floating-point 예외 장치를 사용하는것이다[ISO/IEC 9899:1999]. 그러나 C99 floating-point 예외 함수들에 문제가 없지는 않다. 
덜 portable 하지만 잠재적으로 더 안전한 해법은 구현체에 의해 제공되는 특성들을 사용하는것이다. 이 접근법이 취해지면, 해당 시스템의 조건들이 잘 이해될 필요가 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL37_C</rule>
		<ruleTitle><![CDATA[예약된 식별자를 재선언하거나 재정의 하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 예약된 식별자를 재선언 하거나 재정의 하여 사용하는 것은 정의되지 않은 행동을 유발한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR31_C</rule>
		<ruleTitle><![CDATA[Array 변수의 선언마다 type이 일치하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 배열은 관련된 모든 소스파일에 대해서 일관적인 타입을 사용해야 한다. 단, 같은 파일 내에서 배열이 함수의 인자로 전달되면 포인터로 변환되기 때문에 이 경우에는 강하게 요구되지 않는다. 그러나 함수 프로토타입 밖에서는, 만약 배열이 한 파일에서 포인터 표기를 사용해 선언되었지만 다른 파일에서 배열 표기로 사용되고 있다면, 두 표기는 같지 않다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT06_C</rule>
		<ruleTitle><![CDATA[문자를 integer로 변환하는 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ atoi(), atol(), atoll() 등을 이용하여 문자열 토큰을 integer로 변환하는 방법은 예상하지 못하는 오류들을 발생시킬 가능성이 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>API09_C</rule>
		<ruleTitle><![CDATA[호환되는 값은 같은 타입을 가져야 한다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 호환되는 값은 같은 타입을 가져야 한다. 예를 들어 어떤 함수의 반환값이 다른 함수의 인자로 사용된다고 할 때, 해당 타입들은 같은 타입을 가지도록 해야 묵시적인 변환으로 부터 발생하는 오류를 줄일 수 있다. 쉽게 범할 수 있는 오류로 size_t 타입과 ssize_t 타입을 구분없이 사용하는 경우가 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[Statement의 body가 하나의 statement만을 가지고 있더라도, 항상 body는 block으로 처리해야 한다. 이는 코드의 통일성과 가독성을 향상시킨다. 더욱 중요한 것은, 하나의 statement만 가지는 body에 statement를 추가할 때, brace를 추가하지 않아서 잘못된 코드가 만들어 질 수 있다는 점이다.]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC34_C</rule>
		<ruleTitle><![CDATA[사용이 권장되지 않거나 구형의 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 어떤 함수들은 사용이 권장되지 않거나 새로운 함수를 통해 대체가 가능하다. 이러한 함수들의 사용이 발생하지 않도록 검사한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR06_C</rule>
		<ruleTitle><![CDATA[특정 함수에 사용된 변수가 이 후에 다시 사용되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strtok()이 분할되는 초기 string을 변형시키기 때문에, string은 그 결과 unsafe해지고 원형그대로 사용할수 없게 된다. string원형을 보존하고 싶다면 사본을 만들고 그 주소를 strtok()에 전달해서 사용해야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ bitwise AND (&, ampersand) 또는 bitwise OR (|, pipe) 연산자를 조건식에서 사용하지 말라.  이것은 전형적으로 프로그래머에게 실수를 유발하고 예측하지 못한 작동을 하는 결과가 될수 있다. & 또는 | 는 bitwise 연산에서만 쓰고, && 또는 || 는 논리 연산에서만 써야한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE31_C</rule>
		<ruleTitle><![CDATA[매크로 함수에 side-effect가 있는 인자 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 안전하지 않은 함수형 매크로는 코드 확장에서 파라메터를 한번 이상 평가하거나 전혀 평가하지 않는다. 안전하지 않은 매크로를 절대 할당, 증가, 감소, volatile 접근, 입/출력, 또는 다른 side effect가 있는 인자와 같이 사용해서는 안된다. (함수 호출도 side effect를 일으킬수 있다). 
안전하지 않은 매크로에 대한 문서화는 매크로 사용시 side effect를 일으키는것에 대해 반드시 경고해야 하지만, 매크로 사용의 책임은 프로그래머에게 있다. 그들의 사용에 관련된 위험요소들때문에, 안전하지 않은 매크로함수를 만들지 말것이 제안된다. (제안 PRE00_C 참고) 
aseert() 매크로는 안전하지 않은 매크로의 좋은 예이다. 그것의 인자는 한번 또는 전혀 평가되지 않을수 있고, NDEBUG 매크로에 의존적이다. 더 자세한 정보는 규칙 EXP31_C 참고. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC36_C</rule>
		<ruleTitle><![CDATA[alligned_alloc()으로 할당된 포인터를 가지고 realloc() 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 만약 포인터가 aligned_alloc() 로부터 alignment 를 가지고 반환되었고 realloc() 이 다른 alignment로 메모리를 재할당하였다면, undefined behavior이다. 이 룰은  C1X standard [Jones 2009]를 준수하는 컴파일러에만 적용된다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP01_C</rule>
		<ruleTitle><![CDATA[sizeof()의 인자로 포인터 변수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 특정 타입의 사이즈를 결정할 때 포인터 타입의 사이즈를 사용하면 안된다. 포인터 타입의 사이즈는 포인터가 가리키는 타입의 사이즈가 아니다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO08_C</rule>
		<ruleTitle><![CDATA[remove() 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ remove()함수는 이미 열려 있는 파일에 대하여 호출될 경우에 대한 행동이 정의되어 있지 않다. 따라서 remove() 보다는 unlink()를 권장한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC30_C</rule>
		<ruleTitle><![CDATA[rand() 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ rand()를 사용하여 생성되는 무작위 수는 예측 가능한 수다. 따라서 무작위 수를 사용해야 할 경우에 이 함수를 호출하는 것은 바람직하지 못하다. 대안으로는 srandom()과 현재 시간을 조합하는 방법 또는 윈도우에서 제공하는 CryptGenRandom()를 사용하는 방법이 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR32_C</rule>
		<ruleTitle><![CDATA[시그널 핸들러에서의 금지함수 ]]></ruleTitle>
		<ruleDesc><![CDATA[ [ISO/IEC 9899-1999]에 따르면 abort 또는 raise 함수, 그리고 signal 함수 호출로부터 리턴되는 SIG_ERR을 취한 그에 대응하는 signal handler 호출의 결과로서가 아닌 signal 발생 이후의 errno의 값이 참조될때, 프로그램은 undefined behavior이다. (Annex J 의 undefined behavior 126 참고) 
signal handler는 signal()을 호출하도록 허용되고 만약 실해하면 signal()은 SIG_ERR를 반환하고 errno을 양의 값으로 설정한다. 그러나 signal을 일으킨 사건이 external 이었다면 signal handler 가 호출하게 될 함수는 _Exit() 또는 abort() 또는 현재 처리중인 signal 상의 signal() 뿐이고, signal()이 실패하면 errno값은 정해지지 않는다. 
이 규칙은 SIG31_C의 특별한 경우이다. errno에 의해 지정되는 객체는 static 저장소 수명을 가지고 volatile sig_atomic_t 가 아니다. 결과적으로, errno가 설정될 필요가 있을 어떤 액션을 취하는것은 대개 undefined behavior를 일으킬것이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR02_C</rule>
		<ruleTitle><![CDATA[sprintf 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ sprintf 함수 대신 오류 코드를 반환하는 sprint_m의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<ruleDesc><![CDATA[ errno의 값은 프로그램 기동시에 0 이지만, 어떤 라이브러리 함수에 의해서도 결코 0으로 설정되지 않는다. errno의 값은 C standard 에서 errno의 사용이 함수 설명에 기술되지 않은 라이브러리 함수 호출에 의해서 그것에 에러가 있건 없건간에 0이 아닌값으로 설정될수 있다. 그것은 단지 프로그램에 대해 오류가 보고된 이후 errno의 내용을  조사하기 위한 의미가 있을 뿐이다. 더 정확하게는, errno는 에러 코드를 반환한 에러로 errno를 설정하는 라이브리러 함수 이후에만 의미가 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>SIG30_C</rule>
		<ruleTitle><![CDATA[시그널 핸들러에서는 비동기적으로 안전한 함수만 호출하라 ]]></ruleTitle>
		<ruleDesc><![CDATA[  signal handler안에서는 비동기적으로 안전한(asynchronous-safe)함수만을 호출해야한다. 이 제한은 어플리케이션에 정의된 함수뿐만 아니라 라이브러리 함수들에게도 적용된다. 
C Rationale [ISO/IEC 2003] 의 7.14.1.1 에 따르면, signal이 발생할때, 프로그램의 일반적인 제어흐름은 인터럽트된다. signal handler에 의해 잡히는 signal 발생하면 handler가 불려진다. 그것이 종료될때, signal이 발생했던 지점에서 실행이 계속된다. 이 장치는 signal handler가 signal 시점에 실행되는 라이브러리 함수를 부른다면 문제를 일으킬수 있다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ integer 변환(묵시적, 명시적 모두 포함)은 데이터의 손실이나 부호의 변동을 가져오면 안된다. 이런 변환은 배열의 참조자, 포인터 연산, 객체의 사이즈나 길이 등에서 신뢰하지 못하는 코드를 유발할 수 있다. 단, 해당 변환에 대해 미리 인지하고 검사를 완료한 코드는 허용한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO04_C</rule>
		<ruleTitle><![CDATA[입출력 함수의 성공 또는 실패 여부를 나타내는 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 입출력 함수는 성공 또는 실패 여부를 명백히 나타낸다. 실패한 경우에 반환된 값을 그대로 사용하는 경우 undefined behavior가 발생할 수 있다. 따라서, 입출력 함수의 결과값은 검사되어야 하고 에러가 발생한 경우에는 적절한 에러 처리가 필요하다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>SIG34_C</rule>
		<ruleTitle><![CDATA[interruptible signal handlers 안에서 signal() 함수 호출 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ signal handler들은 자신의 signal을 다루는 목적을 재설정 하지 않아야 한다. 이것은 지속성이 없는(nonpersistent) 플랫폼에서 자주 일어난다. signal을 받는 플랫폼은 연결된 signal handler의 호출 전에 signal에 대한 disposition 을 리셋한다. 
signal handler는 비동기적으로 안전(asynchronous-safe)하게 될 필요가 없을때에만 singal() 을 호출하는것이 좋다. (다른말로하면 모든 해당 signal들은 mask되어야 하고, handler는 interrupt되어서는 안된다.) ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL03_C</rule>
		<ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>SIG32_C</rule>
		<ruleTitle><![CDATA[시그널 핸들러에서는 longjmp() 함수 호출 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ signal handler안에서 longjmp() 함수를 호출하는것은 undefined behavior 를 유도할수 있다. 비동기적으로 안전하지 않은 (non-asynchronous-safe)함수를 호출하게 된다면, 프로그램의 완전성(integrity)이 손상받기 쉽다. longjmp() 뿐만 아니라 POSIX siglongjmp() 또한 signal handler안에서 호출되어서는 안된다. 
이 규칙은 SIG30-C와 밀접하게 연관되어있다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT10_C</rule>
		<ruleTitle><![CDATA[% 연산자를 쓸 때 나머지가 양수라고 가정하지 마라 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99 정의에서 % 연산자에 대한 결과의 부호는 피제수(표현식의 첫 번째 연산자)의 부호를 따른다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL35_C</rule>
		<ruleTitle><![CDATA[function pointer 변수에 return 타입이 일치하지 않는 function assign 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ function pointer 변수에 return 타입이 일치하지 않는 function assign하였는지 검사한다. function pointer에 대응하는 function의 타입이 compatible하지 않으면, function pointer를 사용시 undefined behavior가 발생한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP14_C</rule>
		<ruleTitle><![CDATA[underlying type unsigned char, unsigned short에 대해 bitwise operator(~, <<) 사용시 해당 underlying type으로의 명시적 변환 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ int보다 작은 정수 타입에 대한 bitwise 연산에서는 예상치 못한 결과값이 발생할 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP10_C</rule>
		<ruleTitle><![CDATA[하위 표현식의 평가 순서에 의존하지 않도록 하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 하위 표현식의 평가나 부수 효과가 발생하는 순서가 지정돼 있지 않은 경우는 다음과 같다. 1.함수에 주어진 인자가 평가되는 순서 2.할당문에서 피연산자가 평가되는 순서 3.초기화 표현식에서 나열된 객체들이 부수 효과를 갖는 순서는 지정돼 있지 않다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL01_C</rule>
		<ruleTitle><![CDATA[scope상에서 동일한 identifier 가리는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 한 스코프 영역이 다른 스코프 영역 안에 포함돼 있는 경우 두 스코프에서 동일한 변수 이름을 사용하지 마라. 변수 이름을 재사용할 경우, 프로그래머 입장에선 어떤 변수가 변경되고 있는지 헷갈린다. 변수 이름이 재사용되고 있는 자체가 이름이 너무 일반적이라는 점을 알려준다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE04_C</rule>
		<ruleTitle><![CDATA[표준 헤더를 ""로 include 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 표준 헤더와 같은 이름의 파일이 포함 파일 탐색 경로에 존재하면 undefined behavior이다. 
다음 목록은 표준 헤더를 나열한다.
<assert.h> 	<complex.h> 	<ctype.h> 	<errno.h> 	<fenv.h>
<float.h> 	<inttypes.h> 	<iso646.h> 	<limits.h> 	<locale.h>
<math.h> 	<setjmp.h> 	<signal.h> 	<stdarg.h> 	<stdbool.h>
<stddef.h> 	<stdint.h> 	<stdio.h> 	<stdlib.h> 	<string.h>
<tgmath.h> 	<time.h> 	<uchar.h> 	<wchar.h> 	<wctype.h>
표준 헤더파일 이름, system-specific 헤더파일 이름, 또는 다른 헤더파일 이름을 재활용해서는 안된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO38_C</rule>
		<ruleTitle><![CDATA[FILE 타입끼리 assign하면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 스트림을 제어하는데 사용하는 FILE 객체에서는 주소 값이 중요하다. 하지만 복사된 FILE 객체는 원래 주소를 보존할 필요가 없다. 따라서 입출력 연산 시 FILE 객체를 복사해 사용하지 않는 것이 좋다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC05_C</rule>
		<ruleTitle><![CDATA[time_t 타입에 대해 직접 산술 연산을 수행하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ time_t 타입은 '시간을 표시할 수 있는 산술적인 타입'으로 정의돼 있다. 하지만 이 산술 타입으로 시간을 어떻게 인코딩하는지는 정의돼 있지 않기 때문에 이 타입에 대해 직접 산술 연산을 수행하는 것은 안전하지 않다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR35_C</rule>
		<ruleTitle><![CDATA[고정된 크기의 배열에 제한이 없는 데이터 복사 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strcat(), strcpy()는 제한이 없는 길이의 문자열을 제한이 있는 길이의 버퍼로 복사하면서 오버 플로가 발생할 수 있다. 이를 피하기 위하여 memcpy()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ integer 취약점에 대한 방어의 최일선은 범위검사, 명시적이거나 엄격한 타입검사 이다. 신뢰할수 없는 출처로부터의 integer 값을 강제로 제한하는것도 한가지 접근방법이다(제안 INT04_C 참조). 그러나 제어될수 없는 다양한 입력 변수들이 프로그램의 어딘가의 연산에 에러를 일으키는것을 보장하기 어렵다. 
대안 혹은 보조적인 접근은 개개의 연산을 보호하는것이다. 그러나 이러한 문제에 영향받기 쉬운 큰 수의 integer연산과 예외적 상태를 방지하기 위해 요구되는 많은 검사들 때문에, 이 접근은 엄청나게 노동집약적이고 고비용의 구현이 될수 있다. 
이 문제의 좀더 경제적인 해법은 하나 또는 그 이상의 입력들이 신뢰할수 없는 출처와 결과값에 의해 영향을 받을수 있는 곳, 잘못되면 보안상 헛점을 일으킬수 있는 곳에서 integer에 대한 모든 연산에 대해 secure integer library를 사용하는것이다. 

IntegerLib 

secure integer library 의 한 예는 CERT/CC 에 의해 개발되어 자유롭게 사용 가능한 IntegerLib 이다. 
이 라이브러리의 목적은 integer overflow, integer truncation, sign error등과 같은 일반적인 integer문제로부터 자유로운, C 프로그램을 쓰는 소프트웨어개발자들을 도울수 있는 유틸리티 함수들의 모음을 제공하는것이다. 이 문제들은 소프트웨어취약점의 일반적인 출처이다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM04_C</rule>
		<ruleTitle><![CDATA[특정 함수의 특정 인자로 검증되지 않은 변수 또는 0(constant zero) 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 메모리 할당 시에 사이즈를 0으로 입력하는 것에 대한 처리는 implementation-defined이다. 또한 메모리 할당 함수가 non-null 포인터를 반환하는 경우 할당된 메모리를 읽거나 쓰는 것에 대해서는 undefined behaviord이다. 따라서 메모리 할당 함수에 전달되는 사이즈가 0인지 검사하고 사용해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT01_C</rule>
		<ruleTitle><![CDATA[사이즈 타입 비교 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ size_t 타입은 일반적으로 전체 공간의 주소를 커버한다. ISO/IEC TR 24731-1-2007 는 새로운 타입 rsize_t 를 소개한다. 그것은 size_t로 정의되지만 명시적으로 단일한 object의 크기를 고정하기 위해 사용된다[Meyers 2004]. 이 목적을 문서화한 rsize_t 타입을 사용하는 코드에서 object의 크기는 그것이 RSIZE_MAX보다 크지 않음을 확인하기 위해 검사될수 있다. 일반적인 단일 object의 최대크기인 RSIZE_MAX는 라이브러리 함수에 대한 추가적인 입력 validation을 제공한다. TR 24731-1 의 추가 논의사항에 대해서는 제안 STR07_C 참조. 
object의 크기를 표현하기위해 사용되는 어떤 변수 (크기,인덱스,loop counter,길이로 사용되는 integer값을 포함하는)는 가능한한 rsize_t로 선언되어야 한다. 그렇지 않을경우에는 size_t 로 선언되어야 한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[선언문]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR04_C</rule>
		<ruleTitle><![CDATA[기본 문자 집합에서는 문자들을 위해 plain char를 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 세 개의 타입 char, signed char, unsigned char를 통틀어 문자 타입이라고 한다. 컴파일러는 그것이 signed char이든 unsigned char이든 간에 char가 같은 범위, 표현, 동작을 갖도록 정의한다. 하지만 어느 것을 고르든 char는 나머지 두 개의 타입과는 분리된 타입이고 서로 호환되지 않는다. 기본 문자 집합에서의 문자들은 타입 호환성을 제외하고는 어떤 데이터 타입이 사용되든지 상관하지 않는다. 결과적으로 표준 문자열 처리 함수들과의 호환성을 위해 문자 데이터에는 일반 char를 사용하는 방법이 최선이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL05_C</rule>
		<ruleTitle><![CDATA[function pointer type을 typedef로 사용했는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 코드의 가독성을 높이기 위해 타입 정의(typedef)를 사용하는 것을 권장한다. 함수 포인터 타입의 경우에는 타입 정의를 사용하지 않으면 읽기 어렵고 이해하기도 힘들어진다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC20_C</rule>
		<ruleTitle><![CDATA[Switch label(case, default)을 포함하는 가장 가까운 문장이 switch 문인지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ switch 문에서 새로운 블록이 시작되고 그 안에 case 절이 존재하게 되어 case 절들의 scope이 서로 달라질 수 있다. 만약 루프에 case절이 존재하게 되면 루프 안으로 jump가 발생하게 될 것이다. 이러한 경우 발생하는 행동은 정의되어있지 않다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR34_C</rule>
		<ruleTitle><![CDATA[배열 타입에 대한 incompatible type 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99  section 6.7.5.2 에 따라, 식에 둘 혹은 그 이상의 incompatible array 사용은 undefined behavior를 일으킨다. Appendix J의 undefined behavior 70 참조. compatible해져야 할 두 array 타입에 대해, 양쪽은 compatible underlying element type을 가져야 하고 , 양쪽의 size specifier는 같은 상수값을 가져야 한다. 둘중 하나가 위배되면 undefined behavior를 일으킨다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC16_C</rule>
		<ruleTitle><![CDATA[function pointer 변수에 함수의 pointer를 직접 대입 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수의 메모리 위치는 compile 시점에 계산되며, 프로그램이 늦게 사용하는 순서로 정렬된다. 공격자가 특정 함수 포인터를 덮어 쓸 수 있다면, 임의적인 코드가 수행 될 수 있다. 따라서 이러한 공격에 대비하기 위하여 함수 포인터는 암호화되어 저장하고 사용 시점에 복호화되어 수행되어야 한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>API07_C</rule>
		<ruleTitle><![CDATA[타입의 안전성을 보장하는 함수 사용 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ strncpy()는 결과 문자열이 null로 종료된다는 것을 보장하지 않는다. 따라서 결과 문자열이 null로 종료되지 않았을 경우를 반환값으로 검사할 수 있는 strncpy_s()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 특정 함수 호출 시 전달되는 size가 size_t 타입의 범위를 벗어나는 경우 오버플로가 발생할 수 있다. 따라서 size_t 타입의 사용을 권장한다. 만약 expression 인자의 결과가 size_t 타입의 범위 내라는 보장이 있다면 전체 expression을 size_t로 casting 하기를 권장한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP30_C</rule>
		<ruleTitle><![CDATA[for, while, do에 대해서 floating point 수식을 조건식 및 증감식에서 사용금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ floating-point 숫자는 부분값으로 표현될수 있기때문에, 그것들이 어떤 단순한 부분값을 정확하게 표현할수 있다고 흔히 잘못 가정된다. 사실 floating-point 숫자는 integer가 그렇듯, 그리고 binary floating-point 숫자가 모든 decimal 부분들을 정확히 표현해낼수 없는것과 같이(심지어 그것이 적은수의 10진수 숫자들로 표현될수 있을지라도), 제한된 정밀도에 영향받기 쉽다.
추가적으로, floating-point 숫자는 큰 값을 표현할수 있기때문에 그것들이 그 값들의 모든 자릿수를 표현할수 있을것으로 흔히 잘못 가정된다. 큰 동작범위를 가지기 위해서 floating-point 숫자들은 정해진 수의 정확도와 지수의 비트수를 유지한다. 큰 floating-point 값의 증가는 유효한 정확도 내의 값으로의 변경이 아닐수도 있다.
다른 구현체들은 다른 정밀도제한을 가지며, 코드 이식성 유지를 위해서는 floating-point 변수들을 loop counter로 사용해서는 안된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FIO12_C</rule>
		<ruleTitle><![CDATA[setbuf() 보다 setvbuf() 사용 권장 ]]></ruleTitle>
		<ruleDesc><![CDATA[ setbuf()을 사용하는 것이 setvbuf()를 사용하는 것 보다 오류를 처리하는 능력이 뛰어나다. 따라서 setvbuf()의 사용을 권장한다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR36_C</rule>
		<ruleTitle><![CDATA[포인터 타입에 대한 >, >=, <. <= 연산은 같은 배열의 요소에 대한 pointer에 대해서만 적용 가능 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 두 개의 포인터로 뺄셈을 수행하려면 두 포인터가 같은 배열을 참조하거나 적어도 배열의 마지막 원소 다음 부분을 가리키고 있어야 한다. 이때 결과 값은 배열에서 두 원소 간의 거리가 된다. 이때 C에서의 포인터 뺄셈은 두 포인터 간의 객체 수를 나타내며 바이트 수를 나타내진 않는다는 제한이 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT12_C</rule>
		<ruleTitle><![CDATA[int bit 필드에 명시적으로 signed나 unsigned를 사용하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 저장 공간을 절약하기 위해 플래그나 작은 범위를 갖는 정수 값을 같은 공간에 저장하려고 비트 필드를 사용할 수 있다. 그런데 비트 필드에서 int가 signed int와 같은 타입인지 혹은 unsigned int와 같은 타입인지는 구현마다 다르다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE06_C</rule>
		<ruleTitle><![CDATA[헤더 파일 중복 금지를 위한 처리가 되어있는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 헤더 파일을 포함하는 부분에서 중복된 헤더파일 때문에 문제가 일어날 수 있다. 각 헤더에 '이미 포함됐음' 이라는 의미의 심볼을 정의하여 전체 헤더를 인클루전 가드로 둘러 쌈으로써 해결할 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM01_C</rule>
		<ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ Dangling pointer는 exploitable 이중 free와 free된 메모리 접근 취약점을 이용하도록 유도할수 있다. Dangling pointer를 제거하고 많은 메모리관련 취약점을 피하는 간단하지만 유효한 방법은 포인터에 그들이 free된 후 또는 그들을 다른 적절한 object에 지정한 후에 NULL값을 지정하는것이다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ERR03_C</rule>
		<ruleTitle><![CDATA[TR 24731-1에 정의된 함수를 호출할 때는 런타임 지정 핸들러를 사용하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ ISO/IEC TR 24731-1-2007 에 의해 정의된 대부분 함수들은 그들의 명세의 일부로서 실행시간 제약들의 목록인 실행시간에 다루어질수 있는 위배사항들을 포함한다[ISO/IEC TR 24731-1:2007]. 라이브러리 구현체는 함수에 대한 실행시간 제약들이 프로그램에 의해 위배되지는 않았는지 반드시 검사해야한다. 만약 실행시간 제약들이 위배되면, 일반적으로 set_constraint_handler_s()로 등록한 실행시간 제약 핸들러가 호출된다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>POS34_C</rule>
		<ruleTitle><![CDATA[putenv의 인자로 자동 지속성을 갖는 type 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ POSIX 함수 putenv()는 환경 변수를 설정하기 위해 사용하는 함수다. putenv()는 인자로 전달된 문자열의 사본을 만들지 않고 문자열 포인터를 환경 변수 배열에 그대로 삽입한다. 만일 자동 지속성을 갖는 버퍼 포인터가 putenv()의 인자로 전달된다면 함수가 반환되고 스택 메모리가 다른 용도로 사용될 시점에 버퍼로 할당됐던 메모리 영역이 다른 데이터로 덮어 쓰였을 가능성이 있다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP36_C</rule>
		<ruleTitle><![CDATA[pointer type의 변환 제한 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 다른 타입의 객체에 대해서는 다른 타입의 정렬이 가능하다. 명시적인 캐스팅이나 포인터가 void 포인터로 변환됐다가 다른 타입으로 변경되는 경우로 인해 타입 체크 시스템이 무효화된다면, 객체의 정렬도 바뀔 수 있다. 그 결과 한 객체에 대한 포인터가 다른 객체에 대한 타입으로 변경된 경우, 두 번째 객체의 타입은 처음 것보다 덜 엄격한 정렬을 요구해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP16_C</rule>
		<ruleTitle><![CDATA[함수 이름이 호출식이나 주소연산자(&)가 붙은 형태로만 사용되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ null이 아닌 함수의 포인터를 비교하는 표현식은 대부분 프로그래머의 실수로 그 결과는 정의되지 않는 행동을 유발한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>FLP36_C</rule>
		<ruleTitle><![CDATA[integer 타입을 floating 타입으로 묵시적인 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 작은 primitive 타입은 더 큰 타입으로 묵시적으로 변환될 수 있다. 이런 변환은 정수형 사이에서는 정확한 값을 가지지만 실수형 사이에서는 정확성이 떨어질 수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>POS30_C</rule>
		<ruleTitle><![CDATA[readlink() 함수의 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ readlink() 함수는 링크가 가리키는 곳이 어디인지 읽어온다. 하지만 2번 째 인자로 오는 버퍼에 널 종료문자를 남기지 않는다. 대신 이 함수는 버퍼에 기록된 글자 수를 반환한다. 따라서 반환된 숫자가 -1이 아닌지 확인 후 버퍼를 사용해야 한다. ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL13_C</rule>
		<ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수의 매개 변수를 const로 선언하는 것은 함수가 그 값을 바꾸지 않는다고 약속하는 것과 같다. 함수는 포인터 인자로 참조되는 값을 수정할 수도 있고, 이렇게 수정된 값은 함수가 반환한 후에도 지속된다. 포인터가 참조하는 값을 바꾼 부분은 의도적일 수 있기 때문에 컴파일러가 이를 검사하지는 않는다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE02_C</rule>
		<ruleTitle><![CDATA[매크로로 치환될 영역이 괄호로 감싸졌는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로로 치환될 영역을 괄호로 둘러싸면 근처의 표현식으로 인해 우선순위가 바뀌는 일을 방지할 수 있다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ENV32_C</rule>
		<ruleTitle><![CDATA[atexit 핸들러에서 반환 이외의 방법으로 종료(exit, longjmp)되면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ atexit() 에 등록된 핸들러는 어떤 방법으로도 반환하지 않고 직접 프로그램을 종료해서는 안된다. atexit() 핸들러 전부가 클린업 동작을 수행하게 해주는 일은 매우 중요하며, 보안에 민감한 부분이기도 하다. 특별히 애플리케이션 프로그래머가 알지 못하는 지원 라이브러리에 의해 핸들러가 설치된 경우 더욱 그렇다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ARR02_C</rule>
		<ruleTitle><![CDATA[배열의 사이즈 명시되고 initialize와 일치하는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C표준은 bound와 초기화 literal로 선언되는 배열 변수를 허용한다. 초기화 literal은 또한 명세된 원소들의 수 이내의 배열 bound를 뜻한다. 
컴파일러들이 그들의 초기화 목록에 기반한 배열의 크기를 계산할수 있지만, 명시적으로 배열의 크기를 명세하는것은 배열 크기가 올바른지를 확인할수 있는 여분의 검사를 제공한다. 그것은 또한 컴파일러에게 배열크기 초기화에 의해 암시되는 크기보다 작으면 경고를 해줄수 있도록 한다. 
이 제안은 (모든 경우에서) string literal로 초기화되는 charcter배열에는 적용하지 않는다. STR36_C를 참조. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR37_C</rule>
		<ruleTitle><![CDATA[특정 함수의 특정 인자에서 plain char에서 unsigned char로의 묵시적인 형 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ <ctype.h> 헤더는 문자열을 분류하고 매핑하는 데 유용한 여러 함수를 선언하고 있다. 모든 경우에서 인자는 int 타입이고 표현 가능한 값들은 unsigned char이거나 매크로 EOF와 동일한 값이어야 한다. 인자 값이 이 외의 값을 가질 때의 동작은 정의되어 있지 않다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR33_C</rule>
		<ruleTitle><![CDATA[wide 문자 스트링에 대해 특정 함수 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ Wide character strings은 그것이 narrow strings 또는 multi-byte character strings 으로 오인될때 사이즈가 잘못될수 있다. 부정확한 string 사이즈는 사용될때 버퍼 오버플로우를 유도할수 있다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT09_C</rule>
		<ruleTitle><![CDATA[열거형 상수가 유일한 값으로 매핑되었는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C의 열거형 타입은 정수로 매핑된다. 일반적으로 각 열거형 타입이 개별 값으로 매핑된다고 생각하지만, 열거형 타입 멤버들이 서로 같은 값을 갖는 명확하지 않은 에러가 종종 만들어지기도 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>ENV30_C</rule>
		<ruleTitle><![CDATA[getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ getenv(), setlocale(), localeconv(), strerror() 함수들의 반환 값을 변경하는 것은 undefined behavior를 유발한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM30_C</rule>
		<ruleTitle><![CDATA[free된 포인터 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ [ISO/IEC 9899-1999] 에 따르면, free() 또는 realloc()함수 호출에 의해 해제된 공간을 참조하는 포인터 값을 사용하는 프로그램의 동작은 undefined. (undefined behavior 168 of Annex J 참조) 
한번 free된 메모리에 접근하는것은 heap을 관리하는 자료구조를 파괴할수 있다. 해제된 메모리로의 참조는 dangling pointer로의 참조가 된다. dangling pointer에 접근하는것은 취약점을 드러내는 결과가 될수 있다. 
메모리가 해제될때, 재할당 또는 해제된 chunk를 재활용 할때의 메모리 관리자의 재량권 때문에 그 내용은 아직 변형없이 남아있고 접근 가능하다. 해제된 위치의 데이타는 문제없이 보일수 있다. 그러나 이것은 불시에 변경될수 있고 프로그램을 unintended behavior로 유도한다. 결과적으로 한번 해제된 메모리가 읽거나 쓰이지 않음을 보장할 필요가 있다 ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP05_C</rule>
		<ruleTitle><![CDATA[const를 명시적으로 제거하는 타입 변환 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 포인터의 const qualification을 명시적으로 제거하는 타입 변환을 검사한다. const qualifiication이 제거되면 프로그램이 해당 포인터에 참조되는 object를 수정할 수 있게 되면, 그 결과는 undefined behavior이다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL20_C</rule>
		<ruleTitle><![CDATA[함수 선언과 정의시 파라미터가 없을 경우 명시적인 void 타입 파라미터를 선언했는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수에 인자가 없는 경우라도 반드시 void를 명시해주어야 컴파일러에서 파라미터를 가진 함수인지 검사하지 않는다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT35_C</rule>
		<ruleTitle><![CDATA[정수 표현식으로 비교하거나 할당할 때 더 큰 타입으로 표현하여 묵시적인 변환을 방지하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 정수 표현식이 더 큰 정수와 비교되거나 더 큰 정수에 할당되는 경우 정수 표현은 반드시 피연산자 중 하나를 명시적으로 캐스팅해 큰 타입에서 평가하게 해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL07_C</rule>
		<ruleTitle><![CDATA[함수 정의 시 old style parameter 선언 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 함수는 정확한 타입 선언 정보를 가진 형태로 정의되어야 한다. 만약 함수 선언이 명확하게 구체화되지 않은 경우, 컴파일러에서 함수 타입 정보에 대한 정확한 검사를 할 수 없게 된다. 검사의 일환으로 NonPrototype-Format 선언을 금지한다. C99 표준에서 파라미터 식별자와 선언리스트의 분리는 구식의 방법이라 말하고 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[형식]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC07_C</rule>
		<ruleTitle><![CDATA[도달 불가능한 코드 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 전혀 실행되지 않는 코드는 죽은 코드라고 불린다. 일반적으로 죽은 코드는 프로그램 자체나 환경의 변화로 인해 논리 에러가 발생했음을 암시한다. 죽은 코드는 컴파일되는 동안 프로그램에서 최적화되어 날아가는 게 일반적이다. 하지만 논리 에러가 해결됐음을 보장하고 프로그램의 가독성을 높이기 위해 죽은 코드를 찾아 파악한 후 제거해야 한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[미사용 코드]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM33_C</rule>
		<ruleTitle><![CDATA[유연한 배열 원소에 정확한 문법을 사용하라 ]]></ruleTitle>
		<ruleDesc><![CDATA[ flexible array member는 유용하지만 주의 깊게 사용될 필요가 있다.  
struct flexArrayStruct {	 
int num;	 
int data[];	 
};	 
이 정의는 저장소에 할당될때, 첫번째 멤버 num 만이 고려된다는 것을 의미한다. 따라서 flexArrayStruct type 구조체 변수의 member data 접근 결과는 undefined 이다. 규칙 DCL38_C 이 flexible array member를 가진 구조체를 선언하는 올바른 방법을 설명한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>INT14_C</rule>
		<ruleTitle><![CDATA[bitwise 연산자와 산술 연산자가 혼용되면 안된다. ]]></ruleTitle>
		<ruleDesc><![CDATA[ 동일한 데이터에 비트 연산자와 산술 연산자를 수행하면 안된다. 최적화를 위해 간혹 산술적 수치 값에 비트 연산을 수행하는 경우가 있다. 비트 연산자에는 단항 연산자 ~와 이항 연산자 <<, >>, &, ^, |가 있다. 이런 연산은 유효하고 컴파일도 되지만, 코드의 가독성을 떨어뜨린다. 숫자 값이나 비트맵을 포함하고 있는 변수를 선언할 때, 프로그래머의 의도가 분명하게 보여야 코드의 유지보수가 용이해진다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP31_C</rule>
		<ruleTitle><![CDATA[assert 매크로의 인자로 side-effect 포함 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ assert() 매크로는 코드안에서 진단 테스트를 짜넣기 편리하게 동작한다 (제안 MSC11_C참고) 표준 assert 매크로와 함께 사용된 표현식은 side effect를 가져서는 안된다. 전형적으로, assert 매크로의 동작은 NDEBUG 전처리 심볼의 상태에 의존적이다. NDEBUG가 정의되어있지 않으면, assert 매크로는 그것의 인지 표현식을 평가하도록 정의되고 표현식의 결과가 false 로 변환가능하다면 프로그램을 중단시킨다. NDEBUG가 정의되어 있으면 assert는 아무 동작도 하지 않도록 정의된다. 따라서, assertion에서 표현식의 평가로부터 도출되는 어떤 side effect 는 디버깅버젼이 아닌 코드에서는 잃어버리게 된다. 
assert는 매크로이기 때문에, 이 룰은 PRE31_C의 특별한 케이스이다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[이름 규칙]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE08_C</rule>
		<ruleTitle><![CDATA[헤더파일 중복 include 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 포함되는 헤더파일이 유일한지 확인해야한다. C99[ISO/IEC 9899:1999] 에 따르면 
구현체는 period (.)와 하나의 nondigit가 뒤따르는 하나 또는 그 이상의 nondigit 또는 digit(6.4.2.1)들로 구성된 연속체에 대한 유일한 매핑을 제공해야한다. 첫번째 문자는 숫자여서는 안된다. 구현체는 알파벳 대소문자를 무시할 수 있고, period 앞 기호문자들을 8개로 매핑을 제한할수 있다. 
이것은 다음을 의미한다.
* 파일명의 처음 8문자만이 의미있음을 보증한다.
* 파일은 파일명에서 period 뒤에 단 하나의 nondigit 문자를 가진다.
* 파일명의 대소문자는 의미를 보증하지 않는다.
헤더파일 이름이 유일함을 보증하기 위해 모든 포함파일들은 그들의 처음 여덟자가 다르거나 그들의 (단일문자) 파일 확장자가 달라야한다.
이 제안을 따르는것이 짧을 파일명 사용을 요구하는것은 아니며, 단지 파일명이 유일해야한다는 것이다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>PRE00_C</rule>
		<ruleTitle><![CDATA[함수 매크로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 매크로는 사용법이 함수와 비슷하지만 문법은 다르기 때문에 위험하다. C99에서는 C 프로그래밍 언어에 인라인 함수를 도입했는데, 인라인 함수와 매크로를 모두 사용할 수 있는 경우라면 인라인 함수를 사용하는 편이 좋다. 인라인 함수를 사용하면 우리가 알고 있는 함수 호출 프로시저가 인라인으로 치환되기 때문에 함수 호출이 빨라진다. ]]></ruleDesc>
		<ruleSeverity>높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MSC11_C</rule>
		<ruleTitle><![CDATA[assert 매크로 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ runtime assert는 incorrect assumptions 을 확인하기 위해서만 사용해야 하고, runtime error checking 에서는 사용해서는 안된다. 결과적으로 runtime assertions 은 일반적으로  unsuitable 하다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[하드 코딩]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>MEM08_C</rule>
		<ruleTitle><![CDATA[realloc()의 인자의 타입과 cast되는 타입이 다른지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C standard에 의하면, recalloc(ptr, size) 호출은 ptr이 가리키는 구 객체를 할당해제 하고 size에 의해 크기가 명세되는 새 객체를 반환한다. 새 객체의 내용은 새 객체와 구 객체중 작은쪽의 크기까지 할당해제 전의 구 객체의 내용과 같다, 구 객체의 크기 너머의 새 객체의 바이트들은 결정되지 않은 값들을 가진다. ]]></ruleDesc>
		<ruleSeverity>기타</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ C99 표준은 타입 지정을 항상 요구하고 암시적 함수 선언을 금지한다. 하지만 컴파일러는 이 제한이 나오기 전에 만들어진 코드들과의 호환을 위해 먼저 코드를 진단해보고 암시적 선언을 허용하는 것으로 가정해 컴파일한다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>STR09_C</rule>
		<ruleTitle><![CDATA[plain char type변수와 문자상수값 비교시 부등호 사용 금지 ]]></ruleTitle>
		<ruleDesc><![CDATA[ 이식성있는 어플리케이션을 위해서, plain char 또는 plain wide char 타입 식에 대해 할당 연산자  = , 등가 연산자 == 와 != , 단항연산자 & 만을 사용한다. 
이것은 C99표준이 일관된 수치값[C99 N1401]을 가지기 위해 숫자('0' - '9')만을 요구하기 때문에 제안된다. 따라서, plain character 또는 plain wide character 타입 식에 대한 예상된 값에 의존한 연산들은 예측되지 않은 동작을 할수 있다. 
그러나 숫자에 대한 요구사항때문에, 다른 연산자들은 그것을 위해서 다음 제한들에 따라 사용될수 있다. 
* 이상연산자 + 는 integer값 0 에서 9 에 '0'을 더하기 위해 사용될수 있다.
* 이상연산자 - 는 '0'을 빼기 위해 사용될수 있다.
* 관계연산자 <, <=, >, >= 는 character 또는 wide character 가 숫자인지 판단하기 위해 사용될수 있다. ]]></ruleDesc>
		<ruleSeverity>낮음</ruleSeverity>
		<ruleType><![CDATA[인터페이스]]></ruleType>
	</ruleInfo>
	<ruleInfo>
		<ruleSetName><![CDATA[CERT_C]]></ruleSetName>
		<ruleSetDesc><![CDATA[The CERT C Secure Coding Standard]]></ruleSetDesc>
		<rule>EXP34_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
		<ruleDesc><![CDATA[ null 포인터 결과값을 참조하려는 시도는 undefined behavior이다.  ]]></ruleDesc>
		<ruleSeverity>매우높음</ruleSeverity>
		<ruleType><![CDATA[잠재적 오류]]></ruleType>
	</ruleInfo>
	<bug>
		<violationHash>1655389692344951905212878105257322082176</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[integer underlying type의 부호가 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>104537227556369205654902937037506251798</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>143</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1750832167784285428518007621862937392094</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[DoCaption(struct HWND__ *, char *)]]></function>
		<functionStartLine>100</functionStartLine>
		<functionEndLine>108</functionEndLine>
		<line>100</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 DoCaption의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>154500683876073607401126884494772683889</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>109</line>
		<rule>MEM02_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[할당 후 대상 타입의 포인터로 명시적 변환이 이루어지지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>974550450309722431710590177101410670310</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>116</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135247611551537426473527886554523782556</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>115</line>
		<rule>MEM32_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>502809886329507685717007013785232703752</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>101</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>50663811826631515054970474750312142317</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>58</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>603208239077385146717406475692519080942</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>66</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>96540658920732860547238277171315364434</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>115</line>
		<rule>EXP34_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1207017396252999663412328164719088068306</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>429</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1664487368835536494317454487083750856090</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>179</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 MoveWindow 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>4946469080415025634958926095459707721</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>417</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1521967313753083928816808406609332277432</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>400</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>10121182844626135319693095169677579826</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>439</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 AboutDlgProc는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1467759460839132196415664370647981296966</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileInitialize(struct HWND__ *)]]></function>
		<functionStartLine>12</functionStartLine>
		<functionEndLine>38</functionEndLine>
		<line>33</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>92340108856872227153339638673505160012</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[integer underlying type의 부호가 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68816026302261298253708999570204177550</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>134</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iReturn에 대해 더 작은 타입으로의 손실을 가져오는 묵시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>607292859853291641212660708857385131526</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>131</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1473979106108639613914332364929828600706</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>426</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>20284867901709149992979693733749675530</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>348</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>62058696621119969316968230770615825094</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>208</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>96844115607230083871910690884589650067</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>MEM02_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[할당 후 대상 타입의 포인터로 명시적 변환이 이루어지지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68323048525850461802218794839124677974</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>72</line>
		<rule>MEM01_C</rule>
		<ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[free된 포인터에 즉시 새로운 값을 저장하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>190633314087928856012465779835027161019</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>354</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>930731355383466479510653592577742146809</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>281</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>664752979086100785513884341553435839375</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindValidFind()]]></function>
		<functionStartLine>115</functionStartLine>
		<functionEndLine>118</functionEndLine>
		<line>117</line>
		<rule>STR34_C</rule>
		<ruleTitle><![CDATA[plain char type에 대한 묵시적 변환 제한 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[Plain character 및 signed character가 short이상의 크기를 가진 타입으로 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>54011717312110186943737132691267099231</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontChooseFont(struct HWND__ *)]]></function>
		<functionStartLine>11</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>11</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFontChooseFont의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>133221813370034419492420828237356355695</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontInitialize(struct HWND__ *)]]></function>
		<functionStartLine>34</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>36</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (unsigned -> signed) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>68135754367949310035582015845020774995</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>207</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>64282254930894977010129091227429940187</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>85</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned char 로의 변환 시 secure integer library 의 conversion 함수 si2uc 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>963396126509169090515474626197387244628</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>102</line>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[배열의 인덱스에 signed 타입이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>47587409175645344187537428857186368593</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>193</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 CloseHandle 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>158910244065809130917889005319820508364</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<line>50</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 DeleteObject 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>181356828610791901789249393763089876176</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>119</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 AskAboutSave는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1656620753979916899713491049458026781914</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>60</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFileRead의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1669496716388979903915734358549953404453</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>15</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindReplaceDlg에서만 사용되는 변수 szReplText가 함수 scope에 정의되어 있지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>116408813631243220514657349751773934399</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<line>53</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 InvalidateRect 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>644089817502453715716651896419505477947</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>55</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindFindText의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1476083877530593496889055967170250097</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>103</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(+, *)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1409988961634419746715513767250210637265</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>189</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1583219498027063787417450954110397723396</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>868675554919550208017567955767188054447</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[DoCaption(struct HWND__ *, char *)]]></function>
		<functionStartLine>100</functionStartLine>
		<functionEndLine>108</functionEndLine>
		<line>105</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>149716417960059431299618781604384207243</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>85</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pBuffer로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>399854042836305879217519566581607133663</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>201</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>70276434458310104293694407973124816614</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>101</line>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[배열의 인덱스에 signed 타입이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>352479080697975967917035586006406924254</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindNextText(struct HWND__ *, signed int *)]]></function>
		<functionStartLine>92</functionStartLine>
		<functionEndLine>99</functionEndLine>
		<line>92</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindNextText의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17294719536992222623710600070180907047</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontDeinitialize()]]></function>
		<functionStartLine>56</functionStartLine>
		<functionEndLine>59</functionEndLine>
		<line>58</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 DeleteObject 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>81361816662936847605339093952924270453</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>67</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>164337927283294275418595020335523942508</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>88</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(||, ==)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>31958974120405837202126422993793252380</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>125</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>64222874922264828689097523067465772546</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>65</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>140843532981449819036072121865889906443</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>103</line>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[배열의 인덱스에 signed 타입이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>158599063190348216183813470777693863156</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>71</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pstrDoc로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>41510466794923068406848272099644027819</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>71</line>
		<rule>EXP18_C</rule>
		<ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[condition에 직접적인 assign 연산자가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>463982762449051738113517146673581278148</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<line>52</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 GetClientRect 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1403565050006438329817797198085796781732</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>425</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>55342495412021028524684029988914152213</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>140</line>
		<rule>MEM32_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1481201612627422735518011184965347214246</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>221</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1601071122197020384611263466011916735839</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>196</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 더 작은 타입으로의 손실을 가져오는 묵시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1173596104131218988612402001932458493743</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>146</line>
		<rule>MEM01_C</rule>
		<ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[free된 포인터에 즉시 새로운 값을 저장하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>153272752521504258166407115688053581761</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>188</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iLength에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>9978538552610336371494326914215062619</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>85</line>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[배열의 인덱스에 signed 타입이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>724868757411896013216885499835492276502</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>394</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>608595566422008269012505716204967923616</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>78</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 더 작은 타입으로의 손실을 가져오는 묵시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1470899475142742411117917544267003199977</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc 호출 시 1 번째 인자가 size_t 타입이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>166799790227266511619971249776512828939</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>251</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>40010279857733194622133267501896564831</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>102</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(+, *)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>166898338179551716461760567232068750775</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[OkMessage(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>110</functionStartLine>
		<functionEndLine>117</functionEndLine>
		<line>110</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 OkMessage의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>149778101694352679133634317842918690178</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[DoCaption(struct HWND__ *, char *)]]></function>
		<functionStartLine>100</functionStartLine>
		<functionEndLine>108</functionEndLine>
		<line>100</line>
		<rule>DCL13_C</rule>
		<ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터나 레퍼런스 타입의 인자 szTitleName가 함수 내에서 수정되지 않았지만, 함수의 프로토 타입에서 포인터의 base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>110676717718258396565893917577063326498</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>414</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>109972196090302376925142593393887095510</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>207</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1185607039505476981416263587321235579961</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>430</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[while 문의 body가 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>138844102681874193738874987041062129174</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>430</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1032476086131512500614694265344210742104</violationHash>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<function><![CDATA[PopPrntPrintFile(struct HWND__ *, char *)]]></function>
		<functionStartLine>7</functionStartLine>
		<functionEndLine>11</functionEndLine>
		<line>8</line>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[미사용  변수 pstrTitleName 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>215826209059956166618363398717838581863</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>424</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1599688073776467271617199439318134347063</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>110</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 OkMessage는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>132727253287210693697233355610806592844</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>221</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14568525533210738643545003403338079501</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[OkMessage(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>110</functionStartLine>
		<functionEndLine>117</functionEndLine>
		<line>110</line>
		<rule>DCL13_C</rule>
		<ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터나 레퍼런스 타입의 인자 szTitleName가 함수 내에서 수정되지 않았지만, 함수의 프로토 타입에서 포인터의 base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>78313920420713129733944749676960103421</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>386</line>
		<rule>MSC17_C</rule>
		<ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[문장이 있는 switch절이 throw나 break문으로 끝나지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>171393030345583547410276535530271902409</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>77</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>151799873975863478871754886263071277045</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pBuffer로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>95952955271322951495231851369355924701</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileInitialize(struct HWND__ *)]]></function>
		<functionStartLine>12</functionStartLine>
		<functionEndLine>38</functionEndLine>
		<line>12</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFileInitialize의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3902988440514449576057624415340432429</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>103</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15445756171304640698884563511071910230</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>150730360753023820788306988708960476779</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>83</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 ReadFile 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1739385983908352815415294724365846603348</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>375</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1401344327873955367811364457573815442764</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>219</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>84295324897837094407227132030222589166</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>102</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pText로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>744205209320617150910322544488100787088</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>252</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>87473145636691706652547296806140585502</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AboutDlgProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>439</functionStartLine>
		<functionEndLine>457</functionEndLine>
		<line>440</line>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[미사용  변수 lParam 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>284911352746198391815575121754010506001</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1002796000416548981310332527378004304120</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>109</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1659862595315462292215175240976861507280</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>255792643188540656417602336528233034783</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>100</line>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 DoCaption는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>895064118853519315812009304836836140196</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>369</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1006388585928100851613577634123304068630</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>86</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iPos에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2288735769809939945698560871313037421</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>521407661902133339512829517505682392737</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>206</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1603542684751416354411646287350268772404</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>762439385352980982312244027744293814547</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>83</line>
		<rule>ERR33_C</rule>
		<ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1323989661327105997716372937804080744615</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>115</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135123856125179286143172317390564642850</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>73</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>774139839506802094210696018787954407079</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>164</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>622052424797690378016158974046691352826</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceDlg(struct HWND__ *)]]></function>
		<functionStartLine>36</functionStartLine>
		<functionEndLine>53</functionEndLine>
		<line>46</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>345933159984456724118163455340671461132</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontInitialize(struct HWND__ *)]]></function>
		<functionStartLine>34</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>36</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 더 작은 타입으로의 손실을 가져오는 묵시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>151330243124793548517559948960771667694</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>362</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 PopFindNextText 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>777338875662873441014460099785693792341</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>95427746290429254419443041037062388944</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>85</line>
		<rule>STR04_C</rule>
		<ruleTitle><![CDATA[기본 문자 집합에서는 문자들을 위해 plain char를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[signed char 또는 unsigned char 타입 pBuffer가 숫자 값의 사용 및 저장 외의 용도로 사용되었거나, plain char 타입과 혼용되어 사용되었음.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1503479449464209098110141635409215395466</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>416</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>38180831043414836659839772647304961829</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>82</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1103099768436236043213435434279783025111</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>364</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>3854008789368426889699287333011272354</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>STR04_C</rule>
		<ruleTitle><![CDATA[기본 문자 집합에서는 문자들을 위해 plain char를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[signed char 또는 unsigned char 타입 pBuffer가 숫자 값의 사용 및 저장 외의 용도로 사용되었거나, plain char 타입과 혼용되어 사용되었음.]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>270028736719597267913641391862815910470</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>382</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1099972785337064034713202591737029660731</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>188</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '*'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>119480569423544842835921027573824278398</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>109</line>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc 호출 시 1 번째 인자가 size_t 타입이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>44058199459217276712417021766816275722</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>162</line>
		<rule>EXP18_C</rule>
		<ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[condition에 직접적인 assign 연산자가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>59224721284336790815847216076219714471</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134989518257890785772867620892188110337</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[OkMessage(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>110</functionStartLine>
		<functionEndLine>117</functionEndLine>
		<line>114</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 szTitleName로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>111846595787436047733931083069007838416</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>140</line>
		<rule>EXP34_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1338510592284636410417204938131349078962</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>238</line>
		<rule>MSC17_C</rule>
		<ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[문장이 있는 switch절이 throw나 break문으로 끝나지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1617342114496491158511597579570765525478</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>421</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>301011484810414359113390214294555842162</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontInitialize(struct HWND__ *)]]></function>
		<functionStartLine>34</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>34</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFontInitialize의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>64128520867013661811149877801262980181</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindDlg(struct HWND__ *)]]></function>
		<functionStartLine>17</functionStartLine>
		<functionEndLine>34</functionEndLine>
		<line>28</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>98661143252626218005547961857315002959</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>119</line>
		<rule>DCL13_C</rule>
		<ruleTitle><![CDATA[포인터 타입의 인자가 수정되지 않았을 때 const가 선언되었는지 여부 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[포인터나 레퍼런스 타입의 인자 szTitleName가 함수 내에서 수정되지 않았지만, 함수의 프로토 타입에서 포인터의 base type이 const로 선언되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>268164496911774387312623288289114236706</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>110</line>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 OkMessage는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14566684947423915328511813057043109912</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned char 로의 변환 시 secure integer library 의 conversion 함수 si2uc 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>181807155162524334876156927498850718276</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>219</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>8174557887278742897014922308325540793</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>83</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iFileLength에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>10195190645332996505962298592606415001</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>140313356063904052434849960056561723839</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>99</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1349655546347761716517859055575586606172</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>132</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15262393505188719219522752754473046981</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc 호출 시 1 번째 인자가 size_t 타입이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>648869392637063811517622916102879776333</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>416</line>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[조건식에서 bitwise 연산자 (&,|)가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>572028319845820794115224060560909152843</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>115</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 WideCharToMultiByte 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170626130349322410848427580354961900046</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>195</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>419492746731306468911127570696750681339</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[integer underlying type의 부호가 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>91599730764942462158507915668599593421</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>207</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>80572310411958397575016955482176144609</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>426</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>336476034245219828418006351844138010316</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>188</line>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[integer underlying type의 부호가 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>95424174783427100815217698167864723301</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceDlg(struct HWND__ *)]]></function>
		<functionStartLine>36</functionStartLine>
		<functionEndLine>53</functionEndLine>
		<line>47</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>131398706112943438735400796036334256521</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[OkMessage(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>110</functionStartLine>
		<functionEndLine>117</functionEndLine>
		<line>114</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>160935964494525919394866168727983647894</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontDeinitialize()]]></function>
		<functionStartLine>56</functionStartLine>
		<functionEndLine>59</functionEndLine>
		<line>56</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFontDeinitialize의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>17384132000165866433676300303791440176</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>100</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 DoCaption는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>32396216986598920452956821606265792373</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>97</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>477419160188224676711892307916013335859</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileSaveDlg(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>58</functionEndLine>
		<line>50</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFileSaveDlg의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>84970622505005937027849853537479501785</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>729349461336832676310721837552784350944</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>229</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>60250836356231100049804202102831903689</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileInitialize(struct HWND__ *)]]></function>
		<functionStartLine>12</functionStartLine>
		<functionEndLine>38</functionEndLine>
		<line>32</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>885946835890585465813203745201639761438</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileOpenDlg(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>40</functionStartLine>
		<functionEndLine>48</functionEndLine>
		<line>40</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFileOpenDlg의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1231576604780407252315122610369239381341</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>419</line>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[조건식에서 bitwise 연산자 (&,|)가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>385835533574834791516058169975421172636</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>140</line>
		<rule>ERR33_C</rule>
		<ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>162953394889593609915244359944870859064</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>81</line>
		<rule>MEM30_C</rule>
		<ruleTitle><![CDATA[free된 포인터 사용 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[free(delete)된 object가 dereference되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>168318960270256981874291799589633894494</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>424</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(||, &)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>936560394054313517110492293068932869806</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1507244733446443978117917145822982592477</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>MEM02_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환 값을 즉시 할당된 타입의 포인터로 변환하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[할당 후 대상 타입의 포인터로 명시적 변환이 이루어지지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>150752955270341919955434096729558529448</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>109</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>30217131884096870272845394243843362505</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>125</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 szTitleName로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>159977618841100583315139163908355966056</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>419</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>684735118071618288713363991010940125957</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1128281368716464439517082935255902068812</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>83</line>
		<rule>MEM32_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 할당 성공 여부 반환값이 검증되었는지 검사 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>470269810225269837618371486211625652586</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>65</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1474142441667539375613000195403305206940</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>78</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (unsigned -> signed) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>112900026821774298382829040763960143662</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>97</line>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[조건식에서 bitwise 연산자 (&,|)가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1769088633745332125115367074842159995993</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>187</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>146040949488482603062128939982736452768</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '*'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>756686398983955248916095278426678814592</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>202</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>103334851615809078872675451359817392002</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>14096998373996970653710598822002077620</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>189</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>146726715037743530774084501376848016288</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>263</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>58904751366874043306910110805597772502</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 dwBytesWritten에 대해 더 작은 타입으로의 손실을 가져오는 명시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>706307413285547695726675443010348568</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>157820935404170338452372007203513578750</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>115</line>
		<rule>ERR33_C</rule>
		<ruleTitle><![CDATA[함수의 반환값에 대해 오류 검증을 하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>18360492233834947671198164838070831311</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>101</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pText로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>151079542832101698192635018440190004871</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>429</line>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[조건식에서 bitwise 연산자 (&,|)가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>113951346008734578782283470885215335775</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>84</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 CloseHandle 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>493818182035519664811035794819175353235</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>157</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>43533916184179581103800847858322747803</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1832248960144615248216295147475762550214</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>317</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1146752543470600205612790729084678156781</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(+, *)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1250090220233442265811053969426953563184</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindDlg(struct HWND__ *)]]></function>
		<functionStartLine>17</functionStartLine>
		<functionEndLine>34</functionEndLine>
		<line>27</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>63977134268256951275464357156643302058</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>103</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pText로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>15338017750181293980323872206393036837</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>206</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>313842449675393566617029009362124951659</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>109</line>
		<rule>ERR30_C</rule>
		<ruleTitle><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[errno를 사용하는 라이브러리 함수를 호출하기 전에 errno 값을 0으로 설정하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>113742796752338115465379803775654555269</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>137</line>
		<rule>DCL19_C</rule>
		<ruleTitle><![CDATA[변수나 함수가 사용 가능한 최소 범위에서 선언되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 WndProc는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>741866061695539985913644591909917161560</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceDlg(struct HWND__ *)]]></function>
		<functionStartLine>36</functionStartLine>
		<functionEndLine>53</functionEndLine>
		<line>36</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindReplaceDlg의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>159522982330641766591054393359828151796</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>269</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>918546993923723205215322684957909813134</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<line>43</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFontSetFont의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>893816527782600661716338900781791151928</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindValidFind()]]></function>
		<functionStartLine>115</functionStartLine>
		<functionEndLine>118</functionEndLine>
		<line>115</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindValidFind의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1785084305788687232611167595761090899076</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>196</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>930036273747816031513051901359356481939</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>262</line>
		<rule>EXP20_C</rule>
		<ruleTitle><![CDATA[가독성 향상을 위해 조건 구문을 명시적으로 표기하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[조건 구문을 명시적으로 표기하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>61115505479907220668669682802724502373</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>188</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 WriteFile 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>159626617185727411322540835557438560798</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>359</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>62999394801911205415098892363281134528</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontInitialize(struct HWND__ *)]]></function>
		<functionStartLine>34</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<line>40</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>94268721255968970813222578900252860064</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>220</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>146507161906710360016611934815149882960</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AboutDlgProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>439</functionStartLine>
		<functionEndLine>457</functionEndLine>
		<line>450</line>
		<rule>MSC17_C</rule>
		<ruleTitle><![CDATA[문장이 있는 모든 switch 절이 break문으로 끝나는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[문장이 있는 switch절이 throw나 break문으로 끝나지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>112045176816646715502216127670766106488</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>101</functionStartLine>
		<functionEndLine>113</functionEndLine>
		<line>110</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>94954789219832350614583018595904411705</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>134</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 short 로의 변환 시 secure integer library 의 conversion 함수 si2ss 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>34720217726654707614555852711792178777</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>194</line>
		<rule>MEM01_C</rule>
		<ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[free된 포인터에 즉시 새로운 값을 저장하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>145076477892475871765478809788394139911</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>49</line>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[미사용  변수 hPrevInstance 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>7530328710754577315392728642411666496</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>206</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>219563142826210062112690652923903340584</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>195</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>889829087550914292317485145225814566880</violationHash>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<function><![CDATA[PopPrntPrintFile(struct HWND__ *, char *)]]></function>
		<functionStartLine>7</functionStartLine>
		<functionEndLine>11</functionEndLine>
		<line>7</line>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[미사용  변수 hwndEdit 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1430551042820977363211770864907622077682</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>145</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>285509942085839812916805240974846830572</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc 호출 시 1 번째 인자가 size_t 타입이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>609563844531351772417358316256582187077</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>208</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1460079350160999751216791096558914685311</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>188</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>170604877283077916659520900658554847115</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>219</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>84031801826740054108594400050098229601</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[DoCaption(struct HWND__ *, char *)]]></function>
		<functionStartLine>100</functionStartLine>
		<functionEndLine>108</functionEndLine>
		<line>105</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 szTitleName로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>44657288044189995397516521246341002704</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontChooseFont(struct HWND__ *)]]></function>
		<functionStartLine>11</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<line>27</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[int 에서 unsigned short 로의 변환 시 secure integer library 의 conversion 함수 si2us 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>835182958290545155911909690512950652617</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>81</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 ShowWindow 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>70708779165634844795191075581908602879</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>79</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>984068600217794211615758856361610331382</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>82</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1068995509943642432715554570135499609009</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>101</functionStartLine>
		<functionEndLine>113</functionEndLine>
		<line>106</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1570279536259910156412268804489450621165</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>174</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 CloseHandle 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1375191270738949684315298426836773147767</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>151</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFileWrite의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>66707264501445587232034800613446626507</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>81</line>
		<rule>ARR36_C</rule>
		<ruleTitle><![CDATA[포인터 타입에 대한 >, >=, <. <= 연산은 같은 배열의 요소에 대한 pointer에 대해서만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열간의 뺄셈이 아니거나, 다른 배열의 요소에 대해 pointer 뺄셈연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>165560491287137695998481266864156230579</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>187</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>47285473797076194827307303531334160917</violationHash>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<function><![CDATA[PopPrntPrintFile(struct HWND__ *, char *)]]></function>
		<functionStartLine>7</functionStartLine>
		<functionEndLine>11</functionEndLine>
		<line>7</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopPrntPrintFile의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>42065899201185702873775599244229823962</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>78</line>
		<rule>INT02_C</rule>
		<ruleTitle><![CDATA[정수 변환 규칙을 이해하고 사용하였는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[integer underlying type의 부호가 묵시적으로 변환되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1183838493525818191812932404633257421703</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iLength에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>41368493578119531596336210177743333290</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>82</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 UpdateWindow 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>21147268047566082237774453667978240484</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>175</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 SetFocus 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>135656309290812666436520988054807775683</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>130</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 expression에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>2450274543546501222454473355823112824</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>424</line>
		<rule>EXP17_C</rule>
		<ruleTitle><![CDATA[조건문에서 bitwise 연산자 (&,|) 사용 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[조건식에서 bitwise 연산자 (&,|)가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1128284564644754024712044802504668545450</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>83</line>
		<rule>EXP34_C</rule>
		<ruleTitle><![CDATA[메모리 할당 함수의 반환값이 검증되지 않아 null 포인터 참조가 시도되는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc의 반환 값이 검증되지 않음 (함수 호출 인자로 사용된 경우 검증으로 간주 안 함) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>58086246561428890085953736748520405591</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>INT32_C</rule>
		<ruleTitle><![CDATA[signed 정수 연산이 오버플로되지 않도록 보장해야 한다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[overflow를 초래할 수 있는 연산 '+'의 signed 정수 타입 피연산자가 검증되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>179691353297985097146705344371855618061</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>421</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>184209553947904576988768901665850951706</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>57</line>
		<rule>DCL04_C</rule>
		<ruleTitle><![CDATA[하나의 선언문에 2개 이상의 변수선언 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 선언문에서 두 개 이상의 변수를 선언하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>161149252620506476088682053667060298842</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>170</line>
		<rule>MEM35_C</rule>
		<ruleTitle><![CDATA[malloc, memcpy 함수 사용시 오버플로가 발생하면 안된다. ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[함수 malloc 호출 시 1 번째 인자가 size_t 타입이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>259526324685086741012464782718554525688</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>94</line>
		<rule>ARR37_C</rule>
		<ruleTitle><![CDATA[pointer 연산은 배열이나 배열 요소에 대한 pointer만 적용 가능 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[배열이나 배열요소를 가리키지 않는 포인터 pBuffer로부터의 integer 연산이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>772390746266922610713113266587654041180</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>99</line>
		<rule>EXP00_C</rule>
		<ruleTitle><![CDATA[우선 순위가 다른 연산자 혼용 시 괄호를 사용하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[우선 순위가 다른 연산자(<, /)를 괄호 없이 혼용함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>181141696974546331864125280169305328524</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>199</line>
		<rule>MEM01_C</rule>
		<ruleTitle><![CDATA[free된 포인터에 즉시 새로운 값을 저장하였는지 검사 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[free된 포인터에 즉시 새로운 값을 저장하지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>134458209139391996448957902759576686860</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>220</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1687052491830667526713940571076089548453</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>101</functionStartLine>
		<functionEndLine>113</functionEndLine>
		<line>101</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindReplaceText의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>114115656698228278342778761067685432074</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>220</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 iEnable에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>444005054890162748810875581084741281128</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<line>64</line>
		<rule>EXP18_C</rule>
		<ruleTitle><![CDATA[condition에 assignment 연산자 사용금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[condition에 직접적인 assign 연산자가 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1103382392803206116517834961463642014611</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>97</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 wParam에 대해 묵시적인 부호 변환이 이루어지면 안됨 (unsigned -> signed) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>571548354873404347013863928753587865723</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>58</line>
		<rule>EXP16_C</rule>
		<ruleTitle><![CDATA[함수 이름이 호출식이나 주소연산자(&)가 붙은 형태로만 사용되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 이름 WndProc이 호출식 또는 주소 참조(&)가 아닌 형태로 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>174385383823003230711639275330039526332</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>119</line>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 AskAboutSave는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>6805683308907419426643910360326140167</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>362</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>35285655324138153867714845765632167618</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>394</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 DestroyWindow 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>12356119174521763609668033012435552766</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>86</line>
		<rule>ARR30_C</rule>
		<ruleTitle><![CDATA[배열의 인덱스가 유효한 범위 안에 있음을 보장해야 함 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[배열의 인덱스에 signed 타입이 사용되었음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>633271104519627011613630594770452215225</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>439</line>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 AboutDlgProc는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>138867673012572861235161502497489028272</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>290</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>49400966240694752196414879291161401944</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>420</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>150662679092793245416497250453359222530</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>308</line>
		<rule>STR30_C</rule>
		<ruleTitle><![CDATA[특정 함수의 인자로 string literal 사용 금지 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[string literal이 non-const 타입 인자로 사용되어 함수 내에서 변경될 수 있음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115689326199426830605835587720762997439</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function></function>
		<functionStartLine></functionStartLine>
		<functionEndLine></functionEndLine>
		<line>137</line>
		<rule>DCL15_C</rule>
		<ruleTitle><![CDATA[하나의 파일에서만 쓰인 파일 scope 변수나 함수가 internal linkage를 가지는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[하나의 Translation unit에서만 쓰인 파일 scope 함수 WndProc는 static으로 선언되어야 함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>142734324697241554004441450587194268286</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 dwBytesWritten에 대해 묵시적인 부호 변환이 이루어지면 안됨 (signed -> unsigned) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>115779518972245111941582020011638624283</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>157</line>
		<rule>MSC13_C</rule>
		<ruleTitle><![CDATA[미사용 변수 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[미사용  변수 wByteOrderMark 가 존재함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>128793937312355917168214325362467535527</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AboutDlgProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>439</functionStartLine>
		<functionEndLine>457</functionEndLine>
		<line>451</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EndDialog 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>406263758703546676412080078543531317649</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>387</line>
		<rule>EXP16_C</rule>
		<ruleTitle><![CDATA[함수 이름이 호출식이나 주소연산자(&)가 붙은 형태로만 사용되었는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 이름 AboutDlgProc이 호출식 또는 주소 참조(&)가 아닌 형태로 사용되면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>13882302046790128205617942154239773030</violationHash>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindDlg(struct HWND__ *)]]></function>
		<functionStartLine>17</functionStartLine>
		<functionEndLine>34</functionEndLine>
		<line>17</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 PopFindFindDlg의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>126579361632376102602149082651639783294</violationHash>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<line>49</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[pointer type을 integer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>40360205552465385292228369376198792206</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>151</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1134819674320340879211930386608363395459</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>317</line>
		<rule>EXP19_C</rule>
		<ruleTitle><![CDATA[if, for, while의 body가 복합문으로 되어있는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[if 문의 then 또는 else절이 복합문이 아님 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>64255629529737884414690979047593469402</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>198</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 CloseHandle 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>1532500631802215361767540127380817133</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>92</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 TranslateMessage 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>180768767663058711310897581864280472001</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<line>191</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 dwBytesWritten에 대해 명시적인 부호 변환이 이루어지면 안됨 (unsigned -> signed) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>156782762903755169744547729223474989531</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>221</line>
		<rule>EXP12_C</rule>
		<ruleTitle><![CDATA[반환 타입이 void가 아닌 함수 호출의 결과값이 사용되었는지 검사 ]]></ruleTitle>
		<level>높음</level>
		<content><![CDATA[반환 타입이 void가 아닌 함수 EnableMenuItem 호출의 결과값이 사용되지 않았음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>781574557937119697216391978226112168694</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<line>119</line>
		<rule>DCL31_C</rule>
		<ruleTitle><![CDATA[함수나 변수의 선언이나 정의 시 type을 명시하였는지 검사 ]]></ruleTitle>
		<level>낮음</level>
		<content><![CDATA[함수 AskAboutSave의 definition 이전에 선언이 존재하지 않음 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>12371262538470675874754151790009122394</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<line>208</line>
		<rule>INT11_C</rule>
		<ruleTitle><![CDATA[pointer type과 integer type 간 명시적 변환 금지 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[integer type을 pointer type으로 명시적으로 변환하면 안됨 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>5850871230869265927125928441464562676</violationHash>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<line>97</line>
		<rule>INT31_C</rule>
		<ruleTitle><![CDATA[integer type 변수에 대하여 부호 변환 금지 ]]></ruleTitle>
		<level>매우높음</level>
		<content><![CDATA[integer type의 wParam에 대해 더 작은 타입으로의 손실을 가져오는 묵시적인 변환이 이루어지면 안됨 (wider -> narrower) ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<bug>
		<violationHash>90550128298363194968697723137024119877</violationHash>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<line>102</line>
		<rule>INT03_C</rule>
		<ruleTitle><![CDATA[primitive 연산자 대신 library 함수 사용 권장 ]]></ruleTitle>
		<level>기타</level>
		<content><![CDATA[기본 integer 연산자 대신 secure integer library 의 함수 사용을 권장함 ]]></content>
		<suppression>false</suppression>
		<suppressionDesc></suppressionDesc>
	</bug>
	<metric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileInitialize(struct HWND__ *)]]></function>
		<functionStartLine>12</functionStartLine>
		<functionEndLine>38</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>20.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontChooseFont(struct HWND__ *)]]></function>
		<functionStartLine>11</functionStartLine>
		<functionEndLine>32</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>16.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<function><![CDATA[PopPrntPrintFile(struct HWND__ *, char *)]]></function>
		<functionStartLine>7</functionStartLine>
		<functionEndLine>11</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>1.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileWrite(struct HWND__ *, char *)]]></function>
		<functionStartLine>151</functionStartLine>
		<functionEndLine>202</functionEndLine>
		<cc>4.0</cc>
		<ncl>1.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>7.0</ndf>
		<necl>16.0</necl>
		<modifiedCyclomaticComplexity>4.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>4.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>4.0</returnPointsCnt>
		<MCDCCaseCnt>12.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>12.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>7.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontSetFont(struct HWND__ *)]]></function>
		<functionStartLine>43</functionStartLine>
		<functionEndLine>54</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>5.0</ndf>
		<necl>6.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>5.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontInitialize(struct HWND__ *)]]></function>
		<functionStartLine>34</functionStartLine>
		<functionEndLine>41</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>4.0</ndf>
		<necl>3.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>4.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileRead(struct HWND__ *, char *)]]></function>
		<functionStartLine>60</functionStartLine>
		<functionEndLine>149</functionEndLine>
		<cc>5.0</cc>
		<ncl>3.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>10.0</ndf>
		<necl>27.0</necl>
		<modifiedCyclomaticComplexity>5.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>5.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>2.0</returnPointsCnt>
		<MCDCCaseCnt>16.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>16.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>10.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileSaveDlg(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>50</functionStartLine>
		<functionEndLine>58</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>5.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<function><![CDATA[PopFontDeinitialize()]]></function>
		<functionStartLine>56</functionStartLine>
		<functionEndLine>59</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>1.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<function><![CDATA[PopFileOpenDlg(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>40</functionStartLine>
		<functionEndLine>48</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>5.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AboutDlgProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>439</functionStartLine>
		<functionEndLine>457</functionEndLine>
		<cc>6.0</cc>
		<ncl>2.0</ncl>
		<nfp>4.0</nfp>
		<ncf>NaN</ncf>
		<ndf>1.0</ndf>
		<necl>10.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>4.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>3.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WndProc(struct HWND__ *, unsigned int, unsigned int __w64, signed long __w64)]]></function>
		<functionStartLine>137</functionStartLine>
		<functionEndLine>437</functionEndLine>
		<cc>59.0</cc>
		<ncl>4.0</ncl>
		<nfp>4.0</nfp>
		<ncf>NaN</ncf>
		<ndf>32.0</ndf>
		<necl>160.0</necl>
		<modifiedCyclomaticComplexity>27.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>85.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>35.0</returnPointsCnt>
		<MCDCCaseCnt>94.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>110.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>85.454544</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>32.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[AskAboutSave(struct HWND__ *, char *)]]></function>
		<functionStartLine>119</functionStartLine>
		<functionEndLine>135</functionEndLine>
		<cc>3.0</cc>
		<ncl>2.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>3.0</ndf>
		<necl>6.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>12.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>66.666664</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>3.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[OkMessage(struct HWND__ *, char *, char *)]]></function>
		<functionStartLine>110</functionStartLine>
		<functionEndLine>117</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>2.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[DoCaption(struct HWND__ *, char *)]]></function>
		<functionStartLine>100</functionStartLine>
		<functionEndLine>108</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>2.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>0.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<function><![CDATA[WinMain(struct HINSTANCE__ *, struct HINSTANCE__ *, char *, signed int)]]></function>
		<functionStartLine>49</functionStartLine>
		<functionEndLine>98</functionEndLine>
		<cc>5.0</cc>
		<ncl>3.0</ncl>
		<nfp>4.0</nfp>
		<ncf>NaN</ncf>
		<ndf>14.0</ndf>
		<necl>23.0</necl>
		<modifiedCyclomaticComplexity>5.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>5.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>2.0</returnPointsCnt>
		<MCDCCaseCnt>17.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>17.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>14.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindDlg(struct HWND__ *)]]></function>
		<functionStartLine>17</functionStartLine>
		<functionEndLine>34</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>12.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindFindText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>55</functionStartLine>
		<functionEndLine>90</functionEndLine>
		<cc>3.0</cc>
		<ncl>1.0</ncl>
		<nfp>3.0</nfp>
		<ncf>3.0</ncf>
		<ndf>7.0</ndf>
		<necl>13.0</necl>
		<modifiedCyclomaticComplexity>3.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>3.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>3.0</returnPointsCnt>
		<MCDCCaseCnt>8.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>8.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>7.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceDlg(struct HWND__ *)]]></function>
		<functionStartLine>36</functionStartLine>
		<functionEndLine>53</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>1.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>12.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindReplaceText(struct HWND__ *, signed int *, struct tagFINDREPLACEA *)]]></function>
		<functionStartLine>101</functionStartLine>
		<functionEndLine>113</functionEndLine>
		<cc>2.0</cc>
		<ncl>1.0</ncl>
		<nfp>3.0</nfp>
		<ncf>1.0</ncf>
		<ndf>2.0</ndf>
		<necl>4.0</necl>
		<modifiedCyclomaticComplexity>2.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>2.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>2.0</returnPointsCnt>
		<MCDCCaseCnt>4.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>4.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>100.0</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>2.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindNextText(struct HWND__ *, signed int *)]]></function>
		<functionStartLine>92</functionStartLine>
		<functionEndLine>99</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>2.0</nfp>
		<ncf>1.0</ncf>
		<ndf>1.0</ndf>
		<necl>2.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>1.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<metric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<function><![CDATA[PopFindValidFind()]]></function>
		<functionStartLine>115</functionStartLine>
		<functionEndLine>118</functionEndLine>
		<cc>1.0</cc>
		<ncl>0.0</ncl>
		<nfp>0.0</nfp>
		<ncf>1.0</ncf>
		<ndf>0.0</ndf>
		<necl>1.0</necl>
		<modifiedCyclomaticComplexity>1.0</modifiedCyclomaticComplexity>
		<myersInterval>0.0</myersInterval>
		<staticPathsCnt>1.0</staticPathsCnt>
		<gotoStatementsCnt>0.0</gotoStatementsCnt>
		<returnPointsCnt>1.0</returnPointsCnt>
		<MCDCCaseCnt>0.0</MCDCCaseCnt>
		<booleanExpressionMCDCCaseCnt>0.0</booleanExpressionMCDCCaseCnt>
		<effectivenessOfDecisionMCDCCnt>NaN</effectivenessOfDecisionMCDCCnt>
		<avgStatementsSize>NaN</avgStatementsSize>
		<componentStressComplexity>NaN</componentStressComplexity>
		<distinctOperandsCnt>NaN</distinctOperandsCnt>
		<distinctOperatorsCnt>NaN</distinctOperatorsCnt>
		<distinctCalleesCnt>0.0</distinctCalleesCnt>
		<operandsCnt>NaN</operandsCnt>
		<operatorsCnt>NaN</operatorsCnt>
		<vocabularySize>NaN</vocabularySize>
		<languageScope>NaN</languageScope>
		<decisionStatmentCnt>NaN</decisionStatmentCnt>
	</metric>
	<fileMetric>
		<fileName>C:\Temp\poppad\PopFile.c</fileName>
		<functionCnt>5</functionCnt>
		<physicalLineCnt>203.0</physicalLineCnt>
		<lineOfCodeCnt>134.0</lineOfCodeCnt>
		<lineOfCommentCnt>27</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Temp\poppad\PopFind.c</fileName>
		<functionCnt>6</functionCnt>
		<physicalLineCnt>119.0</physicalLineCnt>
		<lineOfCodeCnt>73.0</lineOfCodeCnt>
		<lineOfCommentCnt>13</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Temp\poppad\PopFont.c</fileName>
		<functionCnt>4</functionCnt>
		<physicalLineCnt>60.0</physicalLineCnt>
		<lineOfCodeCnt>46.0</lineOfCodeCnt>
		<lineOfCommentCnt>4</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Temp\poppad\PopPad.c</fileName>
		<functionCnt>6</functionCnt>
		<physicalLineCnt>458.0</physicalLineCnt>
		<lineOfCodeCnt>334.0</lineOfCodeCnt>
		<lineOfCommentCnt>25</lineOfCommentCnt>
	</fileMetric>
	<fileMetric>
		<fileName>C:\Temp\poppad\PopPrnt0.c</fileName>
		<functionCnt>1</functionCnt>
		<physicalLineCnt>12.0</physicalLineCnt>
		<lineOfCodeCnt>6.0</lineOfCodeCnt>
		<lineOfCommentCnt>3</lineOfCommentCnt>
	</fileMetric>
</ci.CodeInspectorResult>
